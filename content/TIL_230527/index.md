---
emoji: 💡
title: 파이썬 | 자료구조와 알고리즘 (2)
date: '2023-05-27 23:00:00'
author: logkyung
tags: 블로그
categories: 블로그
---

3강 ~ 5강

## 3강. 정렬(sort), 탐색(search)
### 정렬
배열의 원소들을 정해진 기준에 따라 나열하는 것
- ex) 오름차순 정렬, 내림차순 정렬
<br>
### Python에서 리스트의 정렬
(1) sorted()
- 내장함수
- 정렬된 새로운 리스트를 반환, 기존 값 변경 x
(2) sort()
- 리스트의 method
- 기존 리스트의 정렬 연산만 수행, 반환값 x
정렬의 순서를 반대로 하고 싶다면? `reverse=True`
문자열로 이루어진 리스트의 경우
- 사전 순서로 정렬
문자열 길이 순서로 정렬하려면?
- 정렬에 이용하는 key 설정
```
L = ['abcd', 'xyz', 'spam']

sorted(L, key=lambda x: len(x)) # ['xyz', 'abcd', 'spam']
```
길이가 같은 문자열('abcd', 'spam')의 경우 기존 순서대로 정렬(사전순서 아님)
키를 지정하는 또 다른 예
```
L = [{'name': 'John', 'score': 83},
     {'name': 'Paul', 'score': 92}]
L.sort(key=lambda x: x['name']) # 이름 순으로 정렬
L.sort(key=lambda x: x['score'], reverse=True) # 점수가 높은 순으로 정렬
```
<br>
### 탐색 알고리즘 - 선형 탐색(Linear Search)
앞에서부터 순차적으로 탐색
소요 시간은 리스트의 길이에 비례 -> O(n)
원소의 위치를 찾는 문제의 경우 index method를 사용하는 것과 같다
<br>
### 탐색 알고리즘 - 이진 탐색(Binary Search)
탐색하려는 리스트가 정렬되어 있는 경우에만 사용 가능
크기 순으로 정렬되어 있다는 성질을 이용하여 탐색
한 번 비교할 때마다 탐색 범위가 반으로 줄어든다(divide&conquer) -> O(log n)
<br>
### 연습문제
리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.
```
def solution(L, x):
    start, end = 0, len(L)-1
    while start <= end:
        mid = (start+end)//2
        if L[mid] == x:
            return mid
        elif L[mid] < x:      # 중간 값이 x보다 작으면 왼쪽 탐색 종료
            start = mid+1
        else:                 # 중간 값이 x보다 크면 오른쪽 탐색 종료
            end = mid-1
    else:                     # 찾는 값이 없는 경우 -1 반환
        return -1
```
<br>
## 4강. 재귀 알고리즘(Recursive Algorithms) - 기초
### 재귀함수(recursive function)란?
하나의 함수 내에서 자기 자신을 호출하여 작업을 수행하는 것
종결 조건을 써주지 않으면 무한히 반복
반복 연산과 비교했을 때?
- 리스트의 길이에 비례하기 때문에 복잡도는 O(n)로 같다
- 효율성 측면에서는 재귀함수가 효율이 떨어진다
- 함수를 호출하고 리턴하는 데 시간이 더 소요되기 때문
### 연습문제
인자로 0 또는 양의 정수인 x 가 주어질 때, Fibonacci 순열의 해당 값을 구하여 반환하는 함수 solution() 을 완성하세요.
Fibonacci 순열은 아래와 같이 정의됩니다.
F0 = 0
F1 = 1
Fn = Fn - 1 + Fn - 2, n >= 2
```
def solution(x):
    if x <= 1:
        return x
    else:
        return solution(x-1) + solution(x-2)
```
- 처음에 복잡하게 생각하느라 시간이 오래 걸렸는데 순열 식만 코드로 구현하면 되는 문제였다.
- 종결 조건은 반드시 써줄 것 -> 여기서는 F0과 F1일 때 종료 조건 작성
<br>
## 5강. 재귀 알고리즘 응용
### 조합의 수 계산
조합이란 n개의 서로 다른 원소에서 m개를 선택하는 경우의 수
```
def combi(n, m):
    if n == m:      # n개 중에 전부를 택하는 경우
        return 1
    elif m == 0:    # 택하는 게 없을 경우
        return 1
    else:
        return combi(n-1, m) + combi(n-1, m-1)
```
효율성 측면에서 여러 번의 함수 호출이 이루어지는데다가, 한 번 호출 시 두 번의 함수 호출이 발생하므로 효율성이 떨어진다.
효율이 떨어지는데도 재귀를 사용하는 이유는? 하노이의 탑 같이 반복문으로 해결하기 어려운 문제에 유용하게 사용되기 때문
### 연습문제
리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어지고, 또한 탐색의 대상이 되는 리스트 내에서의 범위 인덱스가 l 부터 u 까지로 (인자로) 정해질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.
```
def solution(L, x, l, u):
    if l > u:             # 종료 조건: 찾는 원소가 없을 경우
        return -1
    mid = (l + u) // 2
    if x == L[mid]:
        return mid
    elif x < L[mid]:
        return solution(L, x, l, mid-1)
    else:
        return solution(L, x, mid+1, u)
```
- 이진 탐색을 재귀 함수로 구현하는 문제
- 종결 조건이 l==u라고 생각했는데 이 경우에 양 끝점을 확인하지 못하는 예외 발생
- 반복문에서의 종료 조건을 생각하면 쉽게 해결할 수 있다

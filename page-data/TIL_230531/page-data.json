{"componentChunkName":"component---src-templates-blog-template-js","path":"/TIL_230531/","result":{"data":{"cur":{"id":"fb6a0237-07ae-59dc-aa8b-ae99c2f2ad27","html":"<h2 id=\"9강-연결-리스트-3\" style=\"position:relative;\"><a href=\"#9%EA%B0%95-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-3\" aria-label=\"9강 연결 리스트 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9강. 연결 리스트 (3)</h2>\n<h3 id=\"연결-리스트가-유용한-경우\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EA%B0%80-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-label=\"연결 리스트가 유용한 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결 리스트가 유용한 경우</h3>\n<p>연결 리스트의 장점: 삽입과 삭제가 유용하다\n따라서 중간 삽입과 삭제가 빈번한 시나리오의 경우 연결리스트 사용이 유리할 수 있다.\n하지만 현재의 연결 리스트는 삽입과 삭제 시 position을 앞에서부터 탐색해서 찾아와야 하기 때문에 그다지 유용한 것 같지 않음\n이에 대한 해결책으로 새로운 메서드를 만든다</p>\n<ul>\n<li>insertAt(prev, newNode)</li>\n<li>popAfter(prev)</li>\n</ul>\n<p>position을 인자로 주는 것이 아니라 한 노드를 넘겨주고 그 뒤에 삽입, 뒤의 노드를 삭제하는 방법으로 변경\n하지만 head 노드의 경우 prev 노드가 없는데 어떻게 할 것인가? 하는 문제 발생\n이를 위해 head에 dummy node 추가</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class LinkedList:\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n        self.head.next = self.tail</code></pre></div>\n<p>원소 삽입</p>\n<ul>\n<li>prev가 가리키는 node의 다음에</li>\n<li>newNode를 삽입</li>\n<li>성공/실패에 따라 True/False 반환</li>\n</ul>\n<p>원소 삭제</p>\n<ul>\n<li>prev의 다음 node 삭제</li>\n<li>그 node의 data를 리턴</li>\n<li>주의사항\n<ul>\n<li>prev가 마지막 node일 때: return None</li>\n<li>리스트의 마지막 node 삭제할 때: Tail 조정</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"연습문제\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C\" aria-label=\"연습문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연습문제</h3>\n<p>제 9 강에서 소개된 추상적 자료구조 LinkedList 는 dummy head node 를 가지는 연결 리스트입니다. 이 클래스의 popAfter(), popAt() 메서드들을, 강의 내용에 소개된 요구조건을 만족시키도록 구현하세요.\n이 때, popAt() 메서드의 구현에서는 popAfter() 를 호출하여 이용하도록 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\n\nclass LinkedList:\n\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = Node(None)\n        self.tail = None\n        self.head.next = self.tail\n\n\n    def traverse(self):\n        result = []\n        curr = self.head\n        while curr.next:\n            curr = curr.next\n            result.append(curr.data)\n        return result\n\n\n    def getAt(self, pos):\n        if pos &lt; 0 or pos > self.nodeCount:\n            return None\n\n        i = 0\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n\n        return curr\n\n\n    def insertAfter(self, prev, newNode):\n        newNode.next = prev.next\n        if prev.next is None:\n            self.tail = newNode\n        prev.next = newNode\n        self.nodeCount += 1\n        return True\n\n\n    def insertAt(self, pos, newNode):\n        if pos &lt; 1 or pos > self.nodeCount + 1:\n            return False\n\n        if pos != 1 and pos == self.nodeCount + 1:\n            prev = self.tail\n        else:\n            prev = self.getAt(pos - 1)\n        return self.insertAfter(prev, newNode)\n\n\n    def popAfter(self, prev):\n        if prev.next == None:\n            return None\n        curr = prev.next\n        prev.next = curr.next\n        if curr.next == None:\n            self.tail = prev\n        self.nodeCount -= 1\n        return curr.data\n\n\n    def popAt(self, pos):\n        if pos &lt; 0 or pos > self.nodeCount:\n            raise IndexError\n        prev = self.getAt(pos-1)\n        return self.popAfter(prev)\n\n\ndef solution(x):\n    return 0</code></pre></div>","excerpt":"9강. 연결 리스트 (3) 연결 리스트가 유용한 경우 연결 리스트의 장점: 삽입과 삭제가 유용하다\n따라서 중간 삽입과 삭제가 빈번한 시나리오의 경우 연결리스트 사용이 유리할 수 있다.\n하지만 현재의 연결 리스트는 삽입과 삭제 시 position을 앞에서부터 탐색해서 찾아와야 하기 때문에 그다지 유용한 것 같지 않음\n이에 대한 해결책으로 새로운 메서드를 만든다 insertAt(prev, newNode) popAfter(prev) position을 인자로 주는 것이 아니라 한 노드를 넘겨주고 그 뒤에 삽입, 뒤의 노드를 삭제하는 방법으로 변경\n하지만 head 노드의 경우 prev 노드가 없는데 어떻게 할 것인가? 하는 문제 발생\n이를 위해 head에 dummy node 추가 원소 삽입 prev가 가리키는 node의 다음에 newNode를 삽입 성공/실패에 따라 True/False 반환 원소 삭제 prev의 다음 node 삭제 그 node의 data를 리턴 주의사항 prev가 마지막 n…","frontmatter":{"date":"May 31, 2023","title":"파이썬 자료구조와 알고리즘 (4)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230531/"}},"next":{"id":"c9b21417-b504-5fbe-85e2-1fb87a81a001","html":"<h2 id=\"6강-알고리즘-복잡도complexity\" style=\"position:relative;\"><a href=\"#6%EA%B0%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%B5%EC%9E%A1%EB%8F%84complexity\" aria-label=\"6강 알고리즘 복잡도complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6강. 알고리즘 복잡도(Complexity)</h2>\n<h3 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<p>문제 크기와 해결 시간 사이의 관계</p>\n<h3 id=\"공간-복잡도\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"공간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간 복잡도</h3>\n<p>문제 크기와 필요한 메모리 공간 사이 관계</p>\n<h3 id=\"big-o-notation\" style=\"position:relative;\"><a href=\"#big-o-notation\" aria-label=\"big o notation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Big-O Notation</h3>\n<p>알고리즘 복잡도를 표현할 때 쓰이는 점근 표기법 중 하나\n예를 들어, 입력의 크기가 n일 때</p>\n<ul>\n<li>O(log n): 입력의 크기의 로그에 비례하는 시간 소요</li>\n<li>O(n): 입력 크기에 비례하는 시간 소요</li>\n</ul>\n<h3 id=\"선형-시간-알고리즘-on\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%98%95-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-on\" aria-label=\"선형 시간 알고리즘 on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선형 시간 알고리즘: O(n)</h3>\n<p>무작위 배열에서 최댓값을 찾는 문제에 해당\n끝까지 살펴보기 전에는 알 수 없다</p>\n<ul>\n<li>Average Case: O(n)</li>\n<li>Worst Case: O(n)</li>\n</ul>\n<h3 id=\"로그-시간-알고리즘-olog-n\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-olog-n\" aria-label=\"로그 시간 알고리즘 olog n permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로그 시간 알고리즘: O(log n)</h3>\n<p>크기순으로 정렬된 배열에서 이진 탐색하는 문제</p>\n<h3 id=\"이차-시간-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%B0%A8-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"이차 시간 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이차 시간 알고리즘</h3>\n<p>삽입 정렬과 같은 문제</p>\n<h3 id=\"보다-낮은-복잡도를-가지는-정렬-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EB%8B%A4-%EB%82%AE%EC%9D%80-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%8A%94-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"보다 낮은 복잡도를 가지는 정렬 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보다 낮은 복잡도를 가지는 정렬 알고리즘</h3>\n<p>병합 정렬(merge sort)의 경우 O(nlogn)\n정렬 문제에 대해 O(nlogn)보다 낮은 복잡도를 갖는 알고리즘은 없다.\n<br></p>\n<h2 id=\"7강-연결-리스트-linked-list-1\" style=\"position:relative;\"><a href=\"#7%EA%B0%95-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-linked-list-1\" aria-label=\"7강 연결 리스트 linked list 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7강. 연결 리스트 (Linked List) (1)</h2>\n<h3 id=\"연습문제\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C\" aria-label=\"연습문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연습문제</h3>\n<p>추상적 자료구조로 LinkedList 라는 이름의 클래스가 정의되어 있다고 가정하고, 이 리스트를 처음부터 끝까지 순회하는 메서드 traverse() 를 완성하세요.</p>\n<p>메서드 traverse() 는 리스트를 리턴하되, 이 리스트에는 연결 리스트의 노드들에 들어 있는 데이터 아이템들을 연결 리스트에서의 순서와 같도록 포함합니다. 예를 들어, LinkedList L 에 들어 있는 노드들이 43 -> 85 -> 62 라면, 올바른 리턴 값은 [43, 85, 62] 입니다.</p>\n<p>이 규칙을 적용하면, 빈 연결 리스트에 대한 순회 결과로 traverse() 메서드가 리턴해야 할 올바른 결과는 [] 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n\n    def getAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount:\n            return None\n        i = 1\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n        return curr\n\n    def traverse(self):\n        answer = []\n        curr = self.head\n        while curr:\n            answer.append(curr.data)\n            curr = curr.next\n        return answer</code></pre></div>\n<br>\n## 8강. 연결 리스트 (Linked List) (2)\n### 연습문제\n추상적 자료구조 LinkedList 클래스의 메서드로서 popAt() 메서드를 강의 내용에 소개된 요구조건을 만족시키도록 구현하세요.\n<p>초기 코드로 들어 있는 것은 solution() 함수를 포함하여 다른 부분은 수정하지 말고, def popAt(self, pos): 의 메서드 몸체만 구현하세요.</p>\n<p>만약, 인자로 주어진 pos 가 올바른 범위의 값을 가지지 않는 경우에는 IndexError exception 을 발생시키도록 합니다. 이렇게 하기 위한 코드는 raise IndexError 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\n\nclass LinkedList:\n\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n\n\n    def getAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount:\n            return None\n\n        i = 1\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n\n        return curr\n\n\n    def insertAt(self, pos, newNode):\n        if pos &lt; 1 or pos > self.nodeCount + 1:\n            return False\n\n        if pos == 1:\n            newNode.next = self.head\n            self.head = newNode\n\n        else:\n            if pos == self.nodeCount + 1:\n                prev = self.tail\n            else:\n                prev = self.getAt(pos - 1)\n            newNode.next = prev.next\n            prev.next = newNode\n\n        if pos == self.nodeCount + 1:\n            self.tail = newNode\n\n        self.nodeCount += 1\n        return True\n\n\n    def popAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount or self.nodeCount == 0:\n            raise IndexError\n\n        if self.nodeCount == 1:     # 유일노드의 경우\n            curr = self.head\n            self.head = None\n            self.tail = None\n            self.nodeCount = 0\n            return curr.data\n        else:\n            if pos == 1:\n                curr = self.head\n                self.head = curr.next\n            else:\n                prev = self.getAt(pos-1)\n                curr = prev.next\n                prev.next = curr.next\n                if pos == self.nodeCount:\n                    self.tail = prev\n            self.nodeCount -= 1\n            return curr.data\n\n\n\n    def traverse(self):\n        result = []\n        curr = self.head\n        while curr is not None:\n            result.append(curr.data)\n            curr = curr.next\n        return result</code></pre></div>","frontmatter":{"date":"May 28, 2023","title":"파이썬 자료구조와 알고리즘 (3)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230528/"}},"prev":{"id":"1524538a-fc68-5429-9a45-1944f31e5eb1","html":"<h2 id=\"데이터-타입의-특징과-종류\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-label=\"데이터 타입의 특징과 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 타입의 특징과 종류</h2>\n<p>기본형(Primitive Type)</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol: 유일값 만들 때</li>\n<li>BigInt: 매우 큰 수 다룰 떄</li>\n</ul>\n<p>참조형(Reference Type)</p>\n<ul>\n<li>Object</li>\n</ul>\n<p>연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다.</p>\n<h2 id=\"symbol과-bigint\" style=\"position:relative;\"><a href=\"#symbol%EA%B3%BC-bigint\" aria-label=\"symbol과 bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol과 BigInt</h2>\n<h3 id=\"symbol\" style=\"position:relative;\"><a href=\"#symbol\" aria-label=\"symbol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol</h3>\n<p>: 코드 내에서 유일한 값을 가진 이름을 만들 때 사용</p>\n<p><code class=\"language-text\">const user = Symbol();   // 혹은 Symbol('this is user'); 설명을 덧붙일 수 있다</code></p>\n<p>이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값</p>\n<p>user === “this is user”; // false\nuser === ‘user’ // false</p>\n<p>똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false</p>\n<h3 id=\"bigint\" style=\"position:relative;\"><a href=\"#bigint\" aria-label=\"bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BigInt</h3>\n<p>: 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n최소, 최대 정수보다 큰 수의 연산이 필요한 경우 BigInt를 사용한다.</p>\n<p>사용방법: 일반 정수 마지막에 알파벳 ‘n’을 붙이거나 BigInt라는 함수 사용\n소수표현에는 사용할 수 없다.\n소수 형태 결과가 리턴되는 연산은 소수점 아래를 버리고 정수로 표현된다.\nBigInt끼리만 연산할 수 있고 서로 다른 타입은 명시적 타입 변환을 필요로 한다.</p>","frontmatter":{"date":"June 21, 2023","title":"모던 자바스크립트 (1)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-06-21/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/TIL_230531/","nextSlug":"/TIL_230528/","prevSlug":"/2023-06-21/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
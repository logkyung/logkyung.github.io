{"componentChunkName":"component---src-templates-blog-template-js","path":"/Python_Algorithm/","result":{"data":{"cur":{"id":"deb25420-1614-5eac-a10b-0734b6b28ffa","html":"<h2 id=\"1-정렬된-리스트에-원소-삽입\" style=\"position:relative;\"><a href=\"#1-%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90-%EC%9B%90%EC%86%8C-%EC%82%BD%EC%9E%85\" aria-label=\"1 정렬된 리스트에 원소 삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(1) 정렬된 리스트에 원소 삽입</h2>\n<h3 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h3>\n<p>리스트 L과 정수 x가 인자로 주어질 때, 리스트 내의 올바른 위치에 x를 삽입하여 그 결과 리스트를 반환하는 함수 solution을 완성하세요.</p>\n<ul>\n<li>My solution</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(L, x):\n    for element in L:\n        if x > element:\n            continue\n        idx = L.index(element)\n        L.insert(idx, x)\n        break\n    else:\n        L.append(x)\n    return L</code></pre></div>\n<br>\n## (2) 리스트에서 원소 찾아내기\n### 문제 설명\n인자로 주어지는 리스트 L 내에서, 또한 인자로 주어지는 원소 x가 발견되는 모든 인덱스를 구하여 이 인덱스들로 이루어진 리스트를 반환하는 함수 solution을 완성하세요.\n힌트 1: 리스트의 index() 메서드와 슬라이싱을 활용하는 것이 한 가지 방법이 됩니다.\n힌트 2: 인자로 주어지는 원소가 리스트 내에 존재하지 않을 때의 예외 처리를 \"if x in L\"과 같은 조건문으로 판단할 수 있습니다.\n<ul>\n<li>My solution</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(L, x):\n    answer = []\n    if x not in L:\n        answer.append(-1)\n    else:\n        idx = L.index(x)\n        answer.append(idx)\n        while True:\n            if x not in L[idx+1:]:\n                break\n            else:\n                idx = L[idx+1:].index(x) + len(L[:idx+1])\n                answer.append(idx)\n    return answer</code></pre></div>","excerpt":"(1) 정렬된 리스트에 원소 삽입 문제 설명 리스트 L과 정수 x가 인자로 주어질 때, 리스트 내의 올바른 위치에 x를 삽입하여 그 결과 리스트를 반환하는 함수 solution을 완성하세요. My solution My solution","frontmatter":{"date":"May 26, 2023","title":"파이썬 자료구조와 알고리즘","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/Python_Algorithm/"}},"next":{"id":"f06dc468-9d22-5009-a357-b7321552bf92","html":"<h2 id=\"-javascript-문법-정리\" style=\"position:relative;\"><a href=\"#-javascript-%EB%AC%B8%EB%B2%95-%EC%A0%95%EB%A6%AC\" aria-label=\" javascript 문법 정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>💡 JavaScript 문법 정리</h2>\n<ul>\n<li>return 함수의 역할은 <strong>값 반환</strong> , <strong>함수 종료</strong> 두 가지가 있다.</li>\n<li>함수에 return문의 없으면 함수 종료 시 undefined 반환.</li>\n<li>undefined값의 경우\n<ul>\n<li>변수를 선언하고 아무 값도 할당하지 않았을 때</li>\n<li>반환 값이 없는 함수를 호출한 경우</li>\n<li>파라미터가 있는 함수에 호출 시 아무 값도 넘겨주지 않을 때</li>\n</ul>\n</li>\n<li>옵셔널 파라미터\n<ul>\n<li>함수 정의 시 파라미터에 기본 값을 할당해 준 경우 옵셔널 파라미터라고 함.</li>\n<li>옵셔널 파라미터는 선언할 때 가장 마지막에 해줘야 한다.</li>\n</ul>\n</li>\n<li>상수 선언 시 const 키워드 사용\n<ul>\n<li><code class=\"language-text\">const PI = 3.14;</code></li>\n<li>값을 재할당할 수 없기 때문에 값을 보호할 수 있다.</li>\n<li>선언 시 값을 할당해주지 않으면 안된다.</li>\n<li>상수 이름은 대문자와 밑줄로 표현해야 한다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"for-statement\" style=\"position:relative;\"><a href=\"#for-statement\" aria-label=\"for statement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for statement</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (초기화; 조건부; 증감부) {\n\t동작부분;\n}</code></pre></div>\n<ul>\n<li>증감부는 채울 필요 없이 block 내에 작성해도 됨</li>\n<li>하지만 for 특성 상 증감부가 있기 때문에 block 내의 동작부에는 실제 반복할 내용만 집중, 조건과 관련된 부분은 소괄호 내의 증감부에 작성하여 목적에 맞는 코드 작성</li>\n<li>초기화 부분에서 생성한 변수는 로컬변수이다.</li>\n<li>조건 변수 생성 시 let 사용하는 것을 권장</li>\n</ul>\n<h3 id=\"while-statement\" style=\"position:relative;\"><a href=\"#while-statement\" aria-label=\"while statement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>while statement</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">while (조건부) {\n\t동작부분;\n}</code></pre></div>\n<ul>\n<li>while에는 초기화 부분이 없기 때문에 반복 횟수를 카운트하기 위해서는 while 밖에 global 변수 선언</li>\n<li>조건부는 for문과 동일하게 작성</li>\n<li>반복 횟수 증감조건은 while 내에 작성</li>\n<li>while 문을 사용해야 할 경우\n<ul>\n<li>글로벌 변수를 조건부에서 비교하여 사용하고</li>\n<li>반복문 내에서도 변수를 다루면서</li>\n<li>반복문이 종료된 후에도 변수를 사용해야 할 때</li>\n</ul>\n</li>\n<li>continue;를 사용할 경우에는 증감조건은 continue 앞에 작성해야 무한루프에 빠지지 않는다.</li>\n</ul>\n<h3 id=\"object-객체\" style=\"position:relative;\"><a href=\"#object-%EA%B0%9D%EC%B2%B4\" aria-label=\"object 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Object: 객체</h3>\n<ul>\n<li>여러가지 값을 한 번에 저장해야 할 때 사용</li>\n<li>중괄호 { }로 생성</li>\n<li>여러가지 다양한 값들을 쉼표(,)로 구분하여 저장</li>\n<li>각 값들을 명확하게 하기 위해 key: value 형태로 값을 저장</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let obj = {\n\tKey1: Value1,\n\tKey2: Value2,\n\tKey3: {\n\t  key1: value1,\n\t  key2: value2,\n\t},\n};</code></pre></div>\n<ul>\n<li>property name은 다음 규칙을 만족할 때 따옴표 없이 사용\n<ul>\n<li>첫글자는 문자, 밑줄, 달러($)로 시작해야 한다.</li>\n<li>띄어쓰기는 사용할 수 없다.</li>\n<li>하이픈(-)을 사용할 수 없다.</li>\n</ul>\n</li>\n<li>규칙에 벗어난 이름을 사용해야 할 경우 반드시 따옴표로 감싸줘야 한다.</li>\n<li>객체의 property에 접근하는 방법\n<ul>\n<li>점 표기법</li>\n</ul>\n<code class=\"language-text\">obj.Key1;</code>\n<code class=\"language-text\">obj.Key3.key1;</code>\n<ul>\n<li>대괄호 표기법</li>\n</ul>\n<code class=\"language-text\">obj['Key1'];</code>\n<code class=\"language-text\">obj['Key1']['key1'];</code></li>\n<li>존재하지 않는 property에 접근할 경우 undefined.</li>\n</ul>\n<h3 id=\"for--in문\" style=\"position:relative;\"><a href=\"#for--in%EB%AC%B8\" aria-label=\"for  in문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for … in문</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let obj = {\n\tname: 'kyung',\n\tage: 26,\n\tgender: 'f',\n};\n\nfor (let key in obj) {\n\tconsole.log(key); // name age gender\n\tconsole.log(obj[key]); // kyung 26 f\n}</code></pre></div>\n<ul>\n<li>정수형 프로퍼티 네임 사용 시 주의사항\n<ul>\n<li>프로퍼티 네임에 정수형을 사용할 수 있지만 실제로 사용될 때는 문자열로 형변환 되어서 사용된다.</li>\n<li>이러한 예외적인 프로퍼티 네임은 대괄호 표기법으로만 접근이 가능하다.</li>\n<li>객체는 정수형 프로퍼티 네임을 오름차순으로 먼저 정렬, 나머지 프로퍼티들은 추가한 순서대로 정렬하는 특징이 있다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let myObject = {\n\t3: ‘정수3’,\n\tname: ‘codeit’,\n\t1: ‘정수1’,\n\tbirthDay: ‘2017.5.17’,\n\t2: ‘정수2’,\n};\n\nfor (let key in myObject {\n\tconsole.log(key);  // 1 2 3 name birthDay\n}</code></pre></div>\n<ul>\n<li>for문을 사용하지 않고 콘솔에 객체를 출력만 해도 위와 같은 순서로 출력된다.</li>\n<li>자동으로 정렬되는 특성이 의도치 않은 결과를 가져올 수도 있기 때문에 일반적으로 정수형 프로퍼티는 잘 사용되지 않는다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"array-배열\" style=\"position:relative;\"><a href=\"#array-%EB%B0%B0%EC%97%B4\" aria-label=\"array 배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Array: 배열</h3>\n<ul>\n<li>배열도 객체의 한 종류이다.</li>\n</ul>\n<p><code class=\"language-text\">let dataType = ['number', 'string', 'boolean', 'object', 'null', 'undefined']</code></p>\n<ul>\n<li>존재하지 않는 요소에 접근하려고 하면 undefined 반환.</li>\n<li>배열의 메소드를 삭제할 때 delete 키워드를 사용하면 완벽하게 제거되지 않는다. (값은 지워지지만 그 자리에 undefined 값이 들어가 배열의 길이는 그대로)</li>\n<li>완전히 제거하려면 splice라는 메소드를 사용해야 한다.</li>\n<li>splice(startIndex, deleteCount, item)\n<ul>\n<li>배열이름.splice(startIndex); // startIndex부터 뒤의 모든 요소 삭제</li>\n<li>배열이름.splice(startIndex, deleteCount); // startIndex부터 count개의 요소 삭제</li>\n<li>배열이름.splice(startIndex, deleteCount, item); // 삭제한 요소의 자리에 item값 추가</li>\n<li>만약 2개 이상의 값을 넣으면 나머지 요소의 순서는 뒤로 밀린다.</li>\n<li>deleteCount에 0을 넣고 item 값을 추가하면 아무것도 삭제되지 않고 원하는 자리에 원소를 추가할 수 있다.</li>\n<li>splice를 잘 활용하는 것이 배열을 잘 다루는 법.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"배열의-다양한-메소드\" style=\"position:relative;\"><a href=\"#%EB%B0%B0%EC%97%B4%EC%9D%98-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"배열의 다양한 메소드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>배열의 다양한 메소드</h3>\n<ul>\n<li>배열의 첫 요소 삭제: shift()\n<code class=\"language-text\">array.shift(); // 첫 번째 요소를 삭제한 후 나머지 요소들은 앞으로 당겨온다</code></li>\n<li>배열의 마지막 요소 삭제: pop()\n<code class=\"language-text\">array.pop();</code></li>\n<li>배열의 첫 요소에 값을 추가: unshift(item)\n<code class=\"language-text\">array.unshift(item);</code></li>\n<li>마지막 요소에 값 추가: push(item)\n<code class=\"language-text\">array.push(item);</code></li>\n<li>배열의 양 끝을 다뤄야 할 때 위의 메소드들을 사용한다.</li>\n<li>배열에서 특정 값 찾기\n<code class=\"language-text\">array.indexOf(item);</code>\n<ul>\n<li>item의 index 반환</li>\n<li>값이 없다면 -1 반환</li>\n<li>값이 여러 개 존재할 경우 가장 첫 번째 원소의 index 반환</li>\n</ul>\n<code class=\"language-text\">array.lastIndexOf(item); // 뒤에서부터 탐색</code></li>\n<li>배열에 특정 값 있는지 확인: includes\n<code class=\"language-text\">array.includes(item);</code>\n<ul>\n<li>값이 배열에 존재하는지 여부만 확인하고 싶을 때 사용</li>\n<li>item이 있을 경우 true, 없을 경우 false 반환</li>\n</ul>\n</li>\n<li>배열 뒤집기: reverse\n<code class=\"language-text\">array.reverse();</code>\n<ul>\n<li>배열의 순서를 뒤집을 수 있다.</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"for--of-반복문\" style=\"position:relative;\"><a href=\"#for--of-%EB%B0%98%EB%B3%B5%EB%AC%B8\" aria-label=\"for  of 반복문 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>for … of 반복문</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">for (변수 of 배열) {\n\t동작부;\n}</code></pre></div>\n<ul>\n<li>변수에 배열의 요소가 할당됨.</li>\n<li>참고로 배열도 하나의 객체이기 때문에 for … in 문을 사용할 수 있다.</li>\n<li>for … in 문을 사용할 경우 변수에 인덱스가 할당된다.</li>\n<li>하지만 for … in 문은 객체에 더 최적화 되어있어 배열에는 사용을 권장하지 않는다.</li>\n</ul>\n<h3 id=\"다차원-배열\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%EC%B0%A8%EC%9B%90-%EB%B0%B0%EC%97%B4\" aria-label=\"다차원 배열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다차원 배열</h3>\n<ul>\n<li>배열 또한 배열의 요소가 될 수 있다.</li>\n<li>배열 안에 배열 -> 2차원 배열</li>\n<li>배열 안에 2차원 배열 -> 3차원 배열</li>\n<li>다차원 배열은 값에 의미가 필요한 경우보다 위치나 순서에 중점을 두는 경우 사용한다.</li>\n<li>다차원 배열의 접근은 대괄호 두 개를 연속으로 사용한다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">array = [[1, 2], [3, 4]];\n\nconsole.log(array[0]); // [1, 2]\nconsole.log(array[1]); // [3, 4]\nconsole.log(array[0][0]); // 1\nconsole.log(array[0][1]); // 2\nconsole.log(array[1][0]); // 3\nconsole.log(array[1][1]); // 4</code></pre></div>\n<h3 id=\"숫자형-메소드\" style=\"position:relative;\"><a href=\"#%EC%88%AB%EC%9E%90%ED%98%95-%EB%A9%94%EC%86%8C%EB%93%9C\" aria-label=\"숫자형 메소드 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>숫자형 메소드</h3>\n<ul>\n<li>\n<p>toFixed(0 ~ 100): 파라미터 값만큼 소수점 뒤의 자리수 고정해주는 메소드</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let num = 3.1415;\n\nconsole.log(num.toFixed(3)); // 소수점 뒤 넷째자리에서 반올림하여 출력 -> 3.142\nconsole.log(num.toFixed(7)); // 부족한 자리수만큼 0으로 채워서 출력 -> 3.1415000</code></pre></div>\n<ul>\n<li>이때 데이터 타입은 문자열이므로 숫자형 연산이 필요한 경우 형변환을 해줘야 한다.</li>\n</ul>\n<p><code class=\"language-text\">Number(num.toFixed(7)); or +num.toFixed(7);</code></p>\n</li>\n<li>\n<p>toString(2 ~ 36): 파라미터 값의 진법으로 숫자 변환. 결과값은 문자열.</p>\n</li>\n<li>\n<p>주의할 점: 숫자 뒤에 바로 . 을 사용하면 메소드가 아니라 소수점으로 인식</p>\n</li>\n<li>\n<p>정수형 바로 뒤에 사용할 경우 <code class=\"language-text\">1234..toFixed(3)</code> 혹은 <code class=\"language-text\">(1234).toString(2)</code> 형태로 사용한다.</p>\n</li>\n</ul>\n<h3 id=\"math-객체\" style=\"position:relative;\"><a href=\"#math-%EA%B0%9D%EC%B2%B4\" aria-label=\"math 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Math 객체</h3>\n<ul>\n<li>Math 객체란? JavaScript의 내장객체로 다양한 연산들을 사용할 수 있다.</li>\n<li>Math.abs(x): x의 절댓값 반환</li>\n<li>Math.max(n1, n2, … nn): 여러 값 중 가장 큰 수 반환</li>\n<li>Math.min(n1, n2, … nn): 가장 작은 수 반환</li>\n<li>Math.pow(x, y): x^y 반환</li>\n<li>Math.sqrt(x): x의 제곱근 반환</li>\n<li>Math.round(x): x의 반올림 값 반환</li>\n<li>Math.floor(x): x의 버림 값</li>\n<li>Math.ceil(x): x의 올림 값</li>\n<li>Math.random(): 0 이상 1 미만의 난수</li>\n</ul>\n<h3 id=\"문자열\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%9E%90%EC%97%B4\" aria-label=\"문자열 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문자열</h3>\n<ul>\n<li>length: 공백을 포함한 문자열의 길이</li>\n<li>요소 접근\n<code class=\"language-text\">string[n] // 대괄호 표기법</code>\n<code class=\"language-text\">string.charAt(n) // charAt 메소드 사용</code></li>\n<li>요소 탐색\n<code class=\"language-text\">string.indexOf(문자)</code>\n<code class=\"language-text\">string.lastIndexOf(문자)</code></li>\n<li>대소문자 변환\n<code class=\"language-text\">string.toUpperCase()</code>\n<code class=\"language-text\">string.toLowerCase()</code></li>\n<li>양 끝 공백 제거\n<code class=\"language-text\">string.trim()</code></li>\n<li>부분 문자열 접근\n<code class=\"language-text\">string.slice(start, end)</code>\n<ul>\n<li>start인덱스부터 end-1까지의 범위</li>\n<li>파라미터를 한 개만 넣으면 start인덱스부터 끝까지 범위</li>\n<li>파라미터가 없을 경우 전체 문자열</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"기본형과-참조형\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8%ED%98%95%EA%B3%BC-%EC%B0%B8%EC%A1%B0%ED%98%95\" aria-label=\"기본형과 참조형 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본형과 참조형</h3>\n<ul>\n<li>객체를 제외한 number, string, boolean, null, undefined 타입을 기본형(primitive type)이라고 한다.</li>\n<li>기본형을 변수에 담아 사용할 시 값이 그대로 할당된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let x = 3;\nlet y = x;\n\nconsole.log(x); // 3\nconsole.log(y); // 3\n\ny = 5;\n\nconsole.log(x); // 3\nconsole.log(y); // 5</code></pre></div>\n<ul>\n<li>객체의 경우 참조형(reference type)이라고 하는데 값을 변수에 담아 사용할 시 주소값이 할당된다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let x = {\n\tname: 'Lee',\n};\nlet y = x;\n\ny.birth = 2023;\n\nconsole.log(x); // {name: 'Lee', birth: 2023}\nconsole.log(y); // {name: 'Lee', birth: 2023}</code></pre></div>\n<ul>\n<li>변수에 값을 가리키는 주소값이 할당되기 때문에 y의 값을 변경하면 x는 y가 가리키는 값과 같은 값을 가리키므로 x를 출력해도 birth가 추가되는 것.</li>\n<li>배열도 참조형</li>\n</ul>\n<h3 id=\"참조형-복사\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EC%A1%B0%ED%98%95-%EB%B3%B5%EC%82%AC\" aria-label=\"참조형 복사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참조형 복사</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let arr1 = [1, 2, 3];\nlet arr2 = arr1;\n\narr2.push(4);\n\nconsole.log(arr1); // [1, 2, 3, 4]\nconsole.log(arr2); // [1, 2, 3, 4]\n\nlet arr3 = arr1.slice();\n\narr3.push(5);\n\nconsole.log(arr1); // [1, 2, 3, 4]\nconsole.log(arr3); // [1, 2, 3, 4, 5]</code></pre></div>\n<ul>\n<li>배열의 주소값이 아닌 배열 자체를 복사하고 싶을 때 slice 사용</li>\n<li>객체값을 복사하는 방법은 두 가지\n<ol>\n<li>Object객체의 assign메소드 이용</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let obj1 = {\n\tname: 'Lee',\n};\nlet obj2 = Object.assign({}, obj1);</code></pre></div>\n<ol start=\"2\">\n<li>for … in문으로 복사</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let obj1 = {\n\tname: 'Lee',\n\tbirth: 2023,\n\tgender: 'f',\n};\nlet obj2 = {};\nfor (let key in obj1) {\n\tobj2[key] = obj1[key];\n}</code></pre></div>\n<ul>\n<li>같은 값을 갖지만 서로 독립적인 객체로 복사할 수 있다.</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"May 21, 2023","title":"JavaScript","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/JavaScript/"}},"prev":{"id":"ee1d717f-6704-5dd3-a387-a5e899936b60","html":"<p>3강 ~ 5강</p>\n<h2 id=\"3강-정렬sort-탐색search\" style=\"position:relative;\"><a href=\"#3%EA%B0%95-%EC%A0%95%EB%A0%ACsort-%ED%83%90%EC%83%89search\" aria-label=\"3강 정렬sort 탐색search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3강. 정렬(sort), 탐색(search)</h2>\n<h3 id=\"정렬\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC\" aria-label=\"정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬</h3>\n<p>배열의 원소들을 정해진 기준에 따라 나열하는 것</p>\n<ul>\n<li>ex) 오름차순 정렬, 내림차순 정렬</li>\n</ul>\n<br>\n### Python에서 리스트의 정렬\n(1) sorted()\n- 내장함수\n- 정렬된 새로운 리스트를 반환, 기존 값 변경 x\n(2) sort()\n- 리스트의 method\n- 기존 리스트의 정렬 연산만 수행, 반환값 x\n정렬의 순서를 반대로 하고 싶다면? `reverse=True`\n문자열로 이루어진 리스트의 경우\n- 사전 순서로 정렬\n문자열 길이 순서로 정렬하려면?\n- 정렬에 이용하는 key 설정\n```\nL = ['abcd', 'xyz', 'spam']\n<p>sorted(L, key=lambda x: len(x)) # [‘xyz’, ‘abcd’, ‘spam’]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">길이가 같은 문자열('abcd', 'spam')의 경우 기존 순서대로 정렬(사전순서 아님)\n키를 지정하는 또 다른 예</code></pre></div>\n<p>L = [{‘name’: ‘John’, ‘score’: 83},\n{‘name’: ‘Paul’, ‘score’: 92}]\nL.sort(key=lambda x: x[‘name’]) # 이름 순으로 정렬\nL.sort(key=lambda x: x[‘score’], reverse=True) # 점수가 높은 순으로 정렬</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;br>\n### 탐색 알고리즘 - 선형 탐색(Linear Search)\n앞에서부터 순차적으로 탐색\n소요 시간은 리스트의 길이에 비례 -> O(n)\n원소의 위치를 찾는 문제의 경우 index method를 사용하는 것과 같다\n&lt;br>\n### 탐색 알고리즘 - 이진 탐색(Binary Search)\n탐색하려는 리스트가 정렬되어 있는 경우에만 사용 가능\n크기 순으로 정렬되어 있다는 성질을 이용하여 탐색\n한 번 비교할 때마다 탐색 범위가 반으로 줄어든다(divide&amp;conquer) -> O(log n)\n&lt;br>\n### 연습문제\n리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.</code></pre></div>\n<p>def solution(L, x):\nstart, end = 0, len(L)-1\nwhile start &#x3C;= end:\nmid = (start+end)//2\nif L[mid] == x:\nreturn mid\nelif L[mid] &#x3C; x:      # 중간 값이 x보다 작으면 왼쪽 탐색 종료\nstart = mid+1\nelse:                 # 중간 값이 x보다 크면 오른쪽 탐색 종료\nend = mid-1\nelse:                     # 찾는 값이 없는 경우 -1 반환\nreturn -1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;br>\n## 4강. 재귀 알고리즘(Recursive Algorithms) - 기초\n### 재귀함수(recursive function)란?\n하나의 함수 내에서 자기 자신을 호출하여 작업을 수행하는 것\n종결 조건을 써주지 않으면 무한히 반복\n반복 연산과 비교했을 때?\n- 리스트의 길이에 비례하기 때문에 복잡도는 O(n)로 같다\n- 효율성 측면에서는 재귀함수가 효율이 떨어진다\n- 함수를 호출하고 리턴하는 데 시간이 더 소요되기 때문\n### 연습문제\n인자로 0 또는 양의 정수인 x 가 주어질 때, Fibonacci 순열의 해당 값을 구하여 반환하는 함수 solution() 을 완성하세요.\nFibonacci 순열은 아래와 같이 정의됩니다.\nF0 = 0\nF1 = 1\nFn = Fn - 1 + Fn - 2, n >= 2</code></pre></div>\n<p>def solution(x):\nif x &#x3C;= 1:\nreturn x\nelse:\nreturn solution(x-1) + solution(x-2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 처음에 복잡하게 생각하느라 시간이 오래 걸렸는데 순열 식만 코드로 구현하면 되는 문제였다.\n- 종결 조건은 반드시 써줄 것 -> 여기서는 F0과 F1일 때 종료 조건 작성\n&lt;br>\n## 5강. 재귀 알고리즘 응용\n### 조합의 수 계산\n조합이란 n개의 서로 다른 원소에서 m개를 선택하는 경우의 수</code></pre></div>\n<p>def combi(n, m):\nif n == m:      # n개 중에 전부를 택하는 경우\nreturn 1\nelif m == 0:    # 택하는 게 없을 경우\nreturn 1\nelse:\nreturn combi(n-1, m) + combi(n-1, m-1)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">효율성 측면에서 여러 번의 함수 호출이 이루어지는데다가, 한 번 호출 시 두 번의 함수 호출이 발생하므로 효율성이 떨어진다.\n효율이 떨어지는데도 재귀를 사용하는 이유는? 하노이의 탑 같이 반복문으로 해결하기 어려운 문제에 유용하게 사용되기 때문\n### 연습문제\n리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어지고, 또한 탐색의 대상이 되는 리스트 내에서의 범위 인덱스가 l 부터 u 까지로 (인자로) 정해질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.</code></pre></div>\n<p>def solution(L, x, l, u):\nif l > u:             # 종료 조건: 찾는 원소가 없을 경우\nreturn -1\nmid = (l + u) // 2\nif x == L[mid]:\nreturn mid\nelif x &#x3C; L[mid]:\nreturn solution(L, x, l, mid-1)\nelse:\nreturn solution(L, x, mid+1, u)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 이진 탐색을 재귀 함수로 구현하는 문제\n- 종결 조건이 l==u라고 생각했는데 이 경우에 양 끝점을 확인하지 못하는 예외 발생\n- 반복문에서의 종료 조건을 생각하면 쉽게 해결할 수 있다</code></pre></div>","frontmatter":{"date":"May 27, 2023","title":"파이썬 자료구조와 알고리즘 (2)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230527/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/Python_Algorithm/","nextSlug":"/JavaScript/","prevSlug":"/TIL_230527/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
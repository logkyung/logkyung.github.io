{"componentChunkName":"component---src-templates-blog-template-js","path":"/TIL_230527/","result":{"data":{"cur":{"id":"ee1d717f-6704-5dd3-a387-a5e899936b60","html":"<p>3강 ~ 5강</p>\n<h2 id=\"3강-정렬sort-탐색search\" style=\"position:relative;\"><a href=\"#3%EA%B0%95-%EC%A0%95%EB%A0%ACsort-%ED%83%90%EC%83%89search\" aria-label=\"3강 정렬sort 탐색search permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3강. 정렬(sort), 탐색(search)</h2>\n<h3 id=\"정렬\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A0%AC\" aria-label=\"정렬 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정렬</h3>\n<p>배열의 원소들을 정해진 기준에 따라 나열하는 것</p>\n<ul>\n<li>ex) 오름차순 정렬, 내림차순 정렬</li>\n</ul>\n<br>\n### Python에서 리스트의 정렬\n(1) sorted()\n- 내장함수\n- 정렬된 새로운 리스트를 반환, 기존 값 변경 x\n(2) sort()\n- 리스트의 method\n- 기존 리스트의 정렬 연산만 수행, 반환값 x\n정렬의 순서를 반대로 하고 싶다면? `reverse=True`\n문자열로 이루어진 리스트의 경우\n- 사전 순서로 정렬\n문자열 길이 순서로 정렬하려면?\n- 정렬에 이용하는 key 설정\n```\nL = ['abcd', 'xyz', 'spam']\n<p>sorted(L, key=lambda x: len(x)) # [‘xyz’, ‘abcd’, ‘spam’]</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">길이가 같은 문자열('abcd', 'spam')의 경우 기존 순서대로 정렬(사전순서 아님)\n키를 지정하는 또 다른 예</code></pre></div>\n<p>L = [{‘name’: ‘John’, ‘score’: 83},\n{‘name’: ‘Paul’, ‘score’: 92}]\nL.sort(key=lambda x: x[‘name’]) # 이름 순으로 정렬\nL.sort(key=lambda x: x[‘score’], reverse=True) # 점수가 높은 순으로 정렬</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;br>\n### 탐색 알고리즘 - 선형 탐색(Linear Search)\n앞에서부터 순차적으로 탐색\n소요 시간은 리스트의 길이에 비례 -> O(n)\n원소의 위치를 찾는 문제의 경우 index method를 사용하는 것과 같다\n&lt;br>\n### 탐색 알고리즘 - 이진 탐색(Binary Search)\n탐색하려는 리스트가 정렬되어 있는 경우에만 사용 가능\n크기 순으로 정렬되어 있다는 성질을 이용하여 탐색\n한 번 비교할 때마다 탐색 범위가 반으로 줄어든다(divide&amp;conquer) -> O(log n)\n&lt;br>\n### 연습문제\n리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.</code></pre></div>\n<p>def solution(L, x):\nstart, end = 0, len(L)-1\nwhile start &#x3C;= end:\nmid = (start+end)//2\nif L[mid] == x:\nreturn mid\nelif L[mid] &#x3C; x:      # 중간 값이 x보다 작으면 왼쪽 탐색 종료\nstart = mid+1\nelse:                 # 중간 값이 x보다 크면 오른쪽 탐색 종료\nend = mid-1\nelse:                     # 찾는 값이 없는 경우 -1 반환\nreturn -1</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">&lt;br>\n## 4강. 재귀 알고리즘(Recursive Algorithms) - 기초\n### 재귀함수(recursive function)란?\n하나의 함수 내에서 자기 자신을 호출하여 작업을 수행하는 것\n종결 조건을 써주지 않으면 무한히 반복\n반복 연산과 비교했을 때?\n- 리스트의 길이에 비례하기 때문에 복잡도는 O(n)로 같다\n- 효율성 측면에서는 재귀함수가 효율이 떨어진다\n- 함수를 호출하고 리턴하는 데 시간이 더 소요되기 때문\n### 연습문제\n인자로 0 또는 양의 정수인 x 가 주어질 때, Fibonacci 순열의 해당 값을 구하여 반환하는 함수 solution() 을 완성하세요.\nFibonacci 순열은 아래와 같이 정의됩니다.\nF0 = 0\nF1 = 1\nFn = Fn - 1 + Fn - 2, n >= 2</code></pre></div>\n<p>def solution(x):\nif x &#x3C;= 1:\nreturn x\nelse:\nreturn solution(x-1) + solution(x-2)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 처음에 복잡하게 생각하느라 시간이 오래 걸렸는데 순열 식만 코드로 구현하면 되는 문제였다.\n- 종결 조건은 반드시 써줄 것 -> 여기서는 F0과 F1일 때 종료 조건 작성\n&lt;br>\n## 5강. 재귀 알고리즘 응용\n### 조합의 수 계산\n조합이란 n개의 서로 다른 원소에서 m개를 선택하는 경우의 수</code></pre></div>\n<p>def combi(n, m):\nif n == m:      # n개 중에 전부를 택하는 경우\nreturn 1\nelif m == 0:    # 택하는 게 없을 경우\nreturn 1\nelse:\nreturn combi(n-1, m) + combi(n-1, m-1)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">효율성 측면에서 여러 번의 함수 호출이 이루어지는데다가, 한 번 호출 시 두 번의 함수 호출이 발생하므로 효율성이 떨어진다.\n효율이 떨어지는데도 재귀를 사용하는 이유는? 하노이의 탑 같이 반복문으로 해결하기 어려운 문제에 유용하게 사용되기 때문\n### 연습문제\n리스트 L 과, 그 안에서 찾으려 하는 원소 x 가 인자로 주어지고, 또한 탐색의 대상이 되는 리스트 내에서의 범위 인덱스가 l 부터 u 까지로 (인자로) 정해질 때, x 와 같은 값을 가지는 원소의 인덱스를 리턴하는 함수 solution() 을 완성하세요. 만약 리스트 L 안에 x 와 같은 값을 가지는 원소가 존재하지 않는 경우에는 -1 을 리턴합니다. 리스트 L 은 자연수 원소들로 이루어져 있으며, 크기 순으로 정렬되어 있다고 가정합니다. 또한, 동일한 원소는 두 번 이상 나타나지 않습니다.</code></pre></div>\n<p>def solution(L, x, l, u):\nif l > u:             # 종료 조건: 찾는 원소가 없을 경우\nreturn -1\nmid = (l + u) // 2\nif x == L[mid]:\nreturn mid\nelif x &#x3C; L[mid]:\nreturn solution(L, x, l, mid-1)\nelse:\nreturn solution(L, x, mid+1, u)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">- 이진 탐색을 재귀 함수로 구현하는 문제\n- 종결 조건이 l==u라고 생각했는데 이 경우에 양 끝점을 확인하지 못하는 예외 발생\n- 반복문에서의 종료 조건을 생각하면 쉽게 해결할 수 있다</code></pre></div>","excerpt":"3강 ~ 5강 3강. 정렬(sort), 탐색(search) 정렬 배열의 원소들을 정해진 기준에 따라 나열하는 것 ex) 오름차순 정렬, 내림차순 정렬 sorted(L, key=lambda x: len(x)) # [‘xyz’, ‘abcd’, ‘spam’] L = [{‘name’: ‘John’, ‘score’: 83},\n{‘name’: ‘Paul’, ‘score’: 92}]\nL.sort(key=lambda x: x[‘name’]) # 이름 순으로 정렬\nL.sort(key=lambda x: x[‘score’], reverse=True) # 점수가 높은 순으로 정렬 def solution(L, x):\nstart, end = 0, len(L)-1\nwhile start <= end:\nmid = (start+end)//2\nif L[mid] == x:\nreturn mid\nelif L[mid] < x:      # 중간 값이 x보다 작으면 왼쪽 탐색 종료\nstart = mid+1\nelse:    …","frontmatter":{"date":"May 27, 2023","title":"파이썬 자료구조와 알고리즘 (2)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230527/"}},"next":{"id":"deb25420-1614-5eac-a10b-0734b6b28ffa","html":"<h2 id=\"1-정렬된-리스트에-원소-삽입\" style=\"position:relative;\"><a href=\"#1-%EC%A0%95%EB%A0%AC%EB%90%9C-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EC%97%90-%EC%9B%90%EC%86%8C-%EC%82%BD%EC%9E%85\" aria-label=\"1 정렬된 리스트에 원소 삽입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(1) 정렬된 리스트에 원소 삽입</h2>\n<h3 id=\"문제-설명\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%84%A4%EB%AA%85\" aria-label=\"문제 설명 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제 설명</h3>\n<p>리스트 L과 정수 x가 인자로 주어질 때, 리스트 내의 올바른 위치에 x를 삽입하여 그 결과 리스트를 반환하는 함수 solution을 완성하세요.</p>\n<ul>\n<li>My solution</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(L, x):\n    for element in L:\n        if x > element:\n            continue\n        idx = L.index(element)\n        L.insert(idx, x)\n        break\n    else:\n        L.append(x)\n    return L</code></pre></div>\n<br>\n## (2) 리스트에서 원소 찾아내기\n### 문제 설명\n인자로 주어지는 리스트 L 내에서, 또한 인자로 주어지는 원소 x가 발견되는 모든 인덱스를 구하여 이 인덱스들로 이루어진 리스트를 반환하는 함수 solution을 완성하세요.\n힌트 1: 리스트의 index() 메서드와 슬라이싱을 활용하는 것이 한 가지 방법이 됩니다.\n힌트 2: 인자로 주어지는 원소가 리스트 내에 존재하지 않을 때의 예외 처리를 \"if x in L\"과 같은 조건문으로 판단할 수 있습니다.\n<ul>\n<li>My solution</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">def solution(L, x):\n    answer = []\n    if x not in L:\n        answer.append(-1)\n    else:\n        idx = L.index(x)\n        answer.append(idx)\n        while True:\n            if x not in L[idx+1:]:\n                break\n            else:\n                idx = L[idx+1:].index(x) + len(L[:idx+1])\n                answer.append(idx)\n    return answer</code></pre></div>","frontmatter":{"date":"May 26, 2023","title":"파이썬 자료구조와 알고리즘","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/Python_Algorithm/"}},"prev":{"id":"c9b21417-b504-5fbe-85e2-1fb87a81a001","html":"<h2 id=\"6강-알고리즘-복잡도complexity\" style=\"position:relative;\"><a href=\"#6%EA%B0%95-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B3%B5%EC%9E%A1%EB%8F%84complexity\" aria-label=\"6강 알고리즘 복잡도complexity permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6강. 알고리즘 복잡도(Complexity)</h2>\n<h3 id=\"시간-복잡도\" style=\"position:relative;\"><a href=\"#%EC%8B%9C%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"시간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>시간 복잡도</h3>\n<p>문제 크기와 해결 시간 사이의 관계</p>\n<h3 id=\"공간-복잡도\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%EA%B0%84-%EB%B3%B5%EC%9E%A1%EB%8F%84\" aria-label=\"공간 복잡도 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공간 복잡도</h3>\n<p>문제 크기와 필요한 메모리 공간 사이 관계</p>\n<h3 id=\"big-o-notation\" style=\"position:relative;\"><a href=\"#big-o-notation\" aria-label=\"big o notation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Big-O Notation</h3>\n<p>알고리즘 복잡도를 표현할 때 쓰이는 점근 표기법 중 하나\n예를 들어, 입력의 크기가 n일 때</p>\n<ul>\n<li>O(log n): 입력의 크기의 로그에 비례하는 시간 소요</li>\n<li>O(n): 입력 크기에 비례하는 시간 소요</li>\n</ul>\n<h3 id=\"선형-시간-알고리즘-on\" style=\"position:relative;\"><a href=\"#%EC%84%A0%ED%98%95-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-on\" aria-label=\"선형 시간 알고리즘 on permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>선형 시간 알고리즘: O(n)</h3>\n<p>무작위 배열에서 최댓값을 찾는 문제에 해당\n끝까지 살펴보기 전에는 알 수 없다</p>\n<ul>\n<li>Average Case: O(n)</li>\n<li>Worst Case: O(n)</li>\n</ul>\n<h3 id=\"로그-시간-알고리즘-olog-n\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EA%B7%B8-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-olog-n\" aria-label=\"로그 시간 알고리즘 olog n permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로그 시간 알고리즘: O(log n)</h3>\n<p>크기순으로 정렬된 배열에서 이진 탐색하는 문제</p>\n<h3 id=\"이차-시간-알고리즘\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%B0%A8-%EC%8B%9C%EA%B0%84-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"이차 시간 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이차 시간 알고리즘</h3>\n<p>삽입 정렬과 같은 문제</p>\n<h3 id=\"보다-낮은-복잡도를-가지는-정렬-알고리즘\" style=\"position:relative;\"><a href=\"#%EB%B3%B4%EB%8B%A4-%EB%82%AE%EC%9D%80-%EB%B3%B5%EC%9E%A1%EB%8F%84%EB%A5%BC-%EA%B0%80%EC%A7%80%EB%8A%94-%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98\" aria-label=\"보다 낮은 복잡도를 가지는 정렬 알고리즘 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>보다 낮은 복잡도를 가지는 정렬 알고리즘</h3>\n<p>병합 정렬(merge sort)의 경우 O(nlogn)\n정렬 문제에 대해 O(nlogn)보다 낮은 복잡도를 갖는 알고리즘은 없다.\n<br></p>\n<h2 id=\"7강-연결-리스트-linked-list-1\" style=\"position:relative;\"><a href=\"#7%EA%B0%95-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-linked-list-1\" aria-label=\"7강 연결 리스트 linked list 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7강. 연결 리스트 (Linked List) (1)</h2>\n<h3 id=\"연습문제\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C\" aria-label=\"연습문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연습문제</h3>\n<p>추상적 자료구조로 LinkedList 라는 이름의 클래스가 정의되어 있다고 가정하고, 이 리스트를 처음부터 끝까지 순회하는 메서드 traverse() 를 완성하세요.</p>\n<p>메서드 traverse() 는 리스트를 리턴하되, 이 리스트에는 연결 리스트의 노드들에 들어 있는 데이터 아이템들을 연결 리스트에서의 순서와 같도록 포함합니다. 예를 들어, LinkedList L 에 들어 있는 노드들이 43 -> 85 -> 62 라면, 올바른 리턴 값은 [43, 85, 62] 입니다.</p>\n<p>이 규칙을 적용하면, 빈 연결 리스트에 대한 순회 결과로 traverse() 메서드가 리턴해야 할 올바른 결과는 [] 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\nclass LinkedList:\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n\n    def getAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount:\n            return None\n        i = 1\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n        return curr\n\n    def traverse(self):\n        answer = []\n        curr = self.head\n        while curr:\n            answer.append(curr.data)\n            curr = curr.next\n        return answer</code></pre></div>\n<br>\n## 8강. 연결 리스트 (Linked List) (2)\n### 연습문제\n추상적 자료구조 LinkedList 클래스의 메서드로서 popAt() 메서드를 강의 내용에 소개된 요구조건을 만족시키도록 구현하세요.\n<p>초기 코드로 들어 있는 것은 solution() 함수를 포함하여 다른 부분은 수정하지 말고, def popAt(self, pos): 의 메서드 몸체만 구현하세요.</p>\n<p>만약, 인자로 주어진 pos 가 올바른 범위의 값을 가지지 않는 경우에는 IndexError exception 을 발생시키도록 합니다. 이렇게 하기 위한 코드는 raise IndexError 입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\n\nclass LinkedList:\n\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n\n\n    def getAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount:\n            return None\n\n        i = 1\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n\n        return curr\n\n\n    def insertAt(self, pos, newNode):\n        if pos &lt; 1 or pos > self.nodeCount + 1:\n            return False\n\n        if pos == 1:\n            newNode.next = self.head\n            self.head = newNode\n\n        else:\n            if pos == self.nodeCount + 1:\n                prev = self.tail\n            else:\n                prev = self.getAt(pos - 1)\n            newNode.next = prev.next\n            prev.next = newNode\n\n        if pos == self.nodeCount + 1:\n            self.tail = newNode\n\n        self.nodeCount += 1\n        return True\n\n\n    def popAt(self, pos):\n        if pos &lt; 1 or pos > self.nodeCount or self.nodeCount == 0:\n            raise IndexError\n\n        if self.nodeCount == 1:     # 유일노드의 경우\n            curr = self.head\n            self.head = None\n            self.tail = None\n            self.nodeCount = 0\n            return curr.data\n        else:\n            if pos == 1:\n                curr = self.head\n                self.head = curr.next\n            else:\n                prev = self.getAt(pos-1)\n                curr = prev.next\n                prev.next = curr.next\n                if pos == self.nodeCount:\n                    self.tail = prev\n            self.nodeCount -= 1\n            return curr.data\n\n\n\n    def traverse(self):\n        result = []\n        curr = self.head\n        while curr is not None:\n            result.append(curr.data)\n            curr = curr.next\n        return result</code></pre></div>","frontmatter":{"date":"May 28, 2023","title":"파이썬 자료구조와 알고리즘 (3)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230528/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/TIL_230527/","nextSlug":"/Python_Algorithm/","prevSlug":"/TIL_230528/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/2023-07-05/","result":{"data":{"cur":{"id":"efd3d1de-ce46-5613-8ae3-9d7ef2bf8456","html":"<h2 id=\"and와-or의-연산-방식\" style=\"position:relative;\"><a href=\"#and%EC%99%80-or%EC%9D%98-%EC%97%B0%EC%82%B0-%EB%B0%A9%EC%8B%9D\" aria-label=\"and와 or의 연산 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AND와 OR의 연산 방식</h2>\n<p>자바스크립트에서 논리 연산자는 매번 true나 false를 리턴하는 게 아니라 상황에 따라서 양쪽 값 중 하나를 선택하는 방식으로 동작한다.</p>\n<h3 id=\"and-연산자\" style=\"position:relative;\"><a href=\"#and-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"and 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AND 연산자</h3>\n<p>왼쪽 값이 Truthy면 오르쪽 값 리턴, 왼쪽 값이 Falsy면 왼쪽 값 리턴\n<code class=\"language-text\">console.log(\"Python &amp;&amp; JavaScript\");  // Python이 Truthy이므로 JavaScript 리턴</code></p>\n<h3 id=\"or-연산자\" style=\"position:relative;\"><a href=\"#or-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"or 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OR 연산자</h3>\n<p>왼쪽 값이 Truthy면 왼쪽 값 리턴, 왼쪽 값이 Falsy면 오른쪽 값 리턴</p>\n<ul>\n<li>null &#x26;&#x26; undefined   // null</li>\n<li>0 || true           // true</li>\n<li>‘0’ &#x26;&#x26; NaN          // NaN</li>\n<li>{} || 123           // {}</li>\n</ul>\n<br>\n<h2 id=\"null-병합-연산자-\" style=\"position:relative;\"><a href=\"#null-%EB%B3%91%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-\" aria-label=\"null 병합 연산자  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null 병합 연산자: ??</h2>\n<p>?? 연산자 왼편의 값이 null이거나 undefined라면 연산자 오른쪽 값 리턴, 아니면 왼쪽 값 리턴\n동작 방식은 OR 연산과 비슷하지만 병합 연산자는 왼편 값이 null/undefined인지 확인하고 OR은 falsy인지 확인한다는 차이점이 있다.</p>\n<br>\n<h2 id=\"변수와-스코프\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EC%99%80-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"변수와 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수와 스코프</h2>\n<p>값의 재할당이 필요한 경우 let\n필요하지 않은 경우 const</p>\n<ol>\n<li>변수가 유효한 시점의 차이</li>\n</ol>\n<p>var는 변수를 만들기도 전에 사용 가능하다는 문제가 있다.\nhoisting: 코드 상에서는 선언이 나중에 되었지만 선언이 위로 올라간 듯한 현상\nlet이나 const는 변수 선언 전에 사용할 수 없다.</p>\n<ol start=\"2\">\n<li>var는 중복 선언이 가능하다는 문제</li>\n<li>scope 차이</li>\n</ol>\n<p>var는 함수 스코프\nlet, const는 블록 스코프</p>\n<br>\n<h2 id=\"함수-만드는-방법\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"함수 만드는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 만드는 방법</h2>\n<h3 id=\"1-함수-선언-function-declaration\" style=\"position:relative;\"><a href=\"#1-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8-function-declaration\" aria-label=\"1 함수 선언 function declaration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 함수 선언 (Function Declaration)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function 함수이름(파라미터) {\n  동작\n  return 리턴값\n}</code></pre></div>\n<h3 id=\"2-함수-표현식function-expression\" style=\"position:relative;\"><a href=\"#2-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9Dfunction-expression\" aria-label=\"2 함수 표현식function expression permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 함수 표현식(Function Expression)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const printHello = function() {\n  console.log(\"Hello\");\n};</code></pre></div>\n<p>변수에 함수 선언을 할당하는 방식이다.\n함수 선언은 호이스팅이 가능하지만 표현식은 불가능하다.\n또한 함수 선언은 함수 스코프를 가진다. 표현식은 할당된 변수에 따라 스코프가 달라진다.</p>\n<br>\n<h2 id=\"파라미터와-아규먼트\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8\" aria-label=\"파라미터와 아규먼트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터와 아규먼트</h2>\n<h3 id=\"파라미터parameter\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0parameter\" aria-label=\"파라미터parameter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터(Parameter)</h3>\n<p>함수에서 넘겨받는 부분을 파라미터라고 한다.\n함수를 호출할 때 undefined를 넘겨 기본값이 동작하게 할 수 있다.\n파라미터의 기본값은 앞쪽에 정의된 파라미터를 활용할 수 있다.</p>\n<h3 id=\"아규먼트argument\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8argument\" aria-label=\"아규먼트argument permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아규먼트(Argument)</h3>\n<p>함수 호출 시 파라미터로 넘겨주는 값을 의미한다.\n아규먼트 개수에 따라 유연하게 동작하는 함수를 만드려면 함수 내부에서 arguments라는 아규먼트를 다루는 특별한 객체를 사용할 수 있다.</p>\n<h3 id=\"rest-parameter\" style=\"position:relative;\"><a href=\"#rest-parameter\" aria-label=\"rest parameter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest Parameter</h3>\n<p>파라미터 앞에 마침표 세 개를 붙여서 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function name(...paramenter) {\n\n}</code></pre></div>\n<p>arguments 객체는 유사 배열이라 배열의 메소드를 사용할 수 없다.\n반면 Rest Parameter는 배열이기 때문에 배열의 메소드를 활용할 수 있다.\n일반 파라미터와 함께 사용할 수도 있는데 그럴 땐 반드시 가장 마지막에 작성하도록 한다.</p>\n<br>\n<h2 id=\"arrow-function\" style=\"position:relative;\"><a href=\"#arrow-function\" aria-label=\"arrow function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Arrow Function</h2>\n<p>기존 함수의 선언 방식을 보다 간결하게 만들어주는 문법이다.\n이름이 없는 익명함수이기 때문에 이름을 가진 변수에 할당하거나, 다른 함수의 아규먼트를 선언할 때 활용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">() => {\n  동작\n}</code></pre></div>\n<p>더 짧게 표현도 가능한데</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">number => number*2</code></pre></div>\n<ul>\n<li>파라미터가 하나인 arrow function은 소괄호 부분을 생략할 수 있다.</li>\n<li>파라미터가 두 개 이상이거나 없을 경우 반드시 작성해야 한다.</li>\n<li>내부 동작 부분이 return문 하나로만 이루어져 있다면 중괄호와 함께 리턴 키워드를 생략할 수 있다.</li>\n<li>함수 내부에 리턴문 하나밖에 없지만 리턴 값이 객체인 경우 객체를 소괄호로 감싸야 한다.</li>\n<li>arrow function에는 arguments 객체가 없다.</li>\n</ul>\n<br>\n<h2 id=\"this\" style=\"position:relative;\"><a href=\"#this\" aria-label=\"this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>this</h2>\n<p>브라우저 안에서 자바스크립트가 동작한다면 전역 객체인 window 객체가 this의 기본값이다.\n함수 내부에서 사용할 수 있는데 특히 객체의 메소드를 만들 때 사용한다.\n자바스크립트에서 this는 함수를 호출한 객체를 가리키는 키워드이다.\n일반 함수와 arrow function은 this를 다루는 방식이 다르다.\narrow function에서 this는 호출할 대상에 따라 상대적으로 변하는 것이 아니다.\narror function이 선언되기 직전에 유효한 this 값과 같은 값을 갖게 된다.\n이런 특징 때문에 객체에 메소드를 만들 때는 arrow function보다 일반 함수 사용을 권장한다.</p>\n<br>\n<h2 id=\"객체-지향-프로그래밍\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"객체 지향 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 프로그래밍</h2>\n<p>‘객체’간의 상호작용을 중심으로 하는 프로그래밍</p>\n<h3 id=\"객체-만들기\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"객체 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 만들기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = {\n  email: 'abc123@gmail.com',\n  birth: '1997-01-01',\n  buy(item) {\n    console.log(\"this.email buys item.name\");\n  },\n}\n\nconst item = {\n  name: '스웨터',\n  price: 20000,\n}</code></pre></div>\n<h3 id=\"factory-function\" style=\"position:relative;\"><a href=\"#factory-function\" aria-label=\"factory function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Factory Function</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createUser(email, birth) {\n  const user = {\n    email,\n    birth,\n    buy(item) {\n      console.log('this.email buys item.name');\n    },\n  };\n  return user\n}\n\nconst user1 = createUser('abc123@gmail.com', '1997-01-01');\n</code></pre></div>\n<p>객체를 생성해서 return하는 함수를 Factory Function이라고 한다.</p>\n<h3 id=\"constructor-function\" style=\"position:relative;\"><a href=\"#constructor-function\" aria-label=\"constructor function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constructor Function</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function User(email, birth) {\n  this.email = email,\n  this.birth = birth,\n  this.buy = function(item) {\n    console.log('위랑 똑같음');\n  };\n}\n\nconst user1 = new User(email, birth);</code></pre></div>\n<p>this 키워드는 constructor function으로 생성할 수 있는 해당 객체를 의미한다.\n객체를 여러 개 생성했을 때 각각의 값이 다르게 잘 설정되는 이유는 constructor function의 this가 매번 생성되는 해당 객체를 가리키기 때문이다.</p>\n<ul>\n<li>constructor function으로 객체를 생성하려면 new를 붙여서 호출</li>\n<li>일반 함수와 달리 함수 이름의 첫 번째 알파벳을 대문자로</li>\n</ul>\n<h3 id=\"class\" style=\"position:relative;\"><a href=\"#class\" aria-label=\"class permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class User {\n  constructor(email, birth) {\n    this.email = email,\n    this.birth = birth,\n  }\n\n  buy(item) {\n    console.log('위');\n  }\n}</code></pre></div>\n<ul>\n<li>new 키워드로 객체 생성</li>\n<li>constructor 안에 프로퍼티, 바깥에 메소드를 정의</li>\n</ul>\n<h3 id=\"추상화\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94\" aria-label=\"추상화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화</h3>\n<p>객체 지향 프로그래밍의 핵심 개념 네 가지(추상화, 캡슐화, 상속, 다형성) 중 하나\n어떤 구체적인 존재를 원하는 방향으로 간략화 해서 나타내는 것을 말한다.</p>\n<h3 id=\"캡슐화\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\" aria-label=\"캡슐화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화</h3>\n<p>객체의 특정 프로퍼티에 직접 접근하지 못하도록 막는 것을 말한다.\nsetter/getter 메소드를 통해 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">set email(address) {\n  if (address.includes('@')) {\n    this._email = address;\n  } else {\n    throw new Error(\"invalid email address\");\n  }\n}</code></pre></div>\n<p>숨기고자 하는 프로퍼티 이름을 _를 붙이고 써준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">get email() {\n  return this._email;\n}</code></pre></div>\n<p>원래 있던 email 프로퍼티는 _email 프로퍼티로 교체하고 _email에 직접 접근하기보다 getter, setter를 통해 접근하게 한다.\n특정 프로퍼티에 대한 접근을 미리 정해진 메소드를 통해서만 가능하게 하는 것을 캡슐화라고 하며 캡슐화를 함으로써 프로그램의 안정성을 높일 수 있다.</p>\n<h3 id=\"캡슐화-더-알아보기\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"캡슐화 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화 더 알아보기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createUser(email, birthdate) {\n  let _email = email;\n\n  const user = {\n    birthdate,\n\n    get email() {\n      return _email;\n    },\n\n    set email(address) {\n      if (address.includes('@')) {\n        _email = address;\n      } else {\n        throw new Error('invalid email address');\n      }\n    },\n  };\n\n  return user;\n}</code></pre></div>\n<ul>\n<li>createUser 함수 안에, 객체 바깥에 _email 함수를 선언</li>\n<li>대신 user 객체 안에는 email이라는 getter/setter 설정</li>\n<li>closure: 어떤 함수와 그 함수가 참조할 수 있는 값들로 이루어진 환경을 하나로 묶은 것</li>\n<li>createUser 함수가 실행되는 시점에 email이라는 getter/setter 메소드는 _email이라는 변수 값에 접근할 수 있는 상태</li>\n<li>그리고 핵심은 getter/setter 메소드는 객체가 리턴된 후에도 여전히 _email에 접근하는 것이 가능하다는 것</li>\n<li>이처럼 함수가 정의된 당시에 참조할 수 있었던 변수들을 계속 참조할 수 있는 상태의 함수를 클로저라고 한다.</li>\n</ul>\n<h3 id=\"상속inheritance\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8Dinheritance\" aria-label=\"상속inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속(Inheritance)</h3>\n<p>하나의 객체가 다른 객체의 프로퍼티와 메소드를 물려받는 것\n상속받은 자식 클래스는 super 생성자를 호출해야 한다.</p>\n<p>자식 클래스를 만들 때는 자식 클래스의 생성자 안에서 super를 통해 부모 클래스의 생성자 함수를 먼저 호출해줘야 한다.</p>\n<h3 id=\"다형성polymorphism\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1polymorphism\" aria-label=\"다형성polymorphism permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성(Polymorphism)</h3>\n<p>많은 형태를 갖고 있는 성질</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">buy(item) {\n  console.log('this.email buys item.name with a 5% discount');\n}\n\nusers = [user 배열]\n\nusers.forEach((user) => {\n  user.buy(item);\n});</code></pre></div>\n<p>하나의 변수가 다양한 종류의 객체를 가리킬 수 있는 것을 다형성이라고 한다.</p>","excerpt":"AND와 OR의 연산 방식 자바스크립트에서 논리 연산자는 매번 true나 false를 리턴하는 게 아니라 상황에 따라서 양쪽 값 중 하나를 선택하는 방식으로 동작한다. AND 연산자 왼쪽 값이 Truthy면 오르쪽 값 리턴, 왼쪽 값이 Falsy면 왼쪽 값 리턴\n OR 연산자 왼쪽 값이 Truthy면 왼쪽 값 리턴, 왼쪽 값이 Falsy면 오른쪽 값 리턴 null && undefined   // null 0 || true           // true ‘0’ && NaN          // NaN {} || 123           // {} null 병합 연산자: ?? ?? 연산자 왼편의 값이 null이거나 undefined라면 연산자 오른쪽 값 리턴, 아니면 왼쪽 값 리턴\n동작 방식은 OR 연산과 비슷하지만 병합 연산자는 왼편 값이 null/undefined인지 확인하고 OR은 falsy인지 확인한다는 차이점이 있다. 변수와 스코프 값의 재할당이 필요한 경우 let\n필요하지…","frontmatter":{"date":"July 05, 2023","title":"모던 자바스크립트 (2)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-05/"}},"next":{"id":"1524538a-fc68-5429-9a45-1944f31e5eb1","html":"<h2 id=\"데이터-타입의-특징과-종류\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-label=\"데이터 타입의 특징과 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 타입의 특징과 종류</h2>\n<p>기본형(Primitive Type)</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol: 유일값 만들 때</li>\n<li>BigInt: 매우 큰 수 다룰 떄</li>\n</ul>\n<p>참조형(Reference Type)</p>\n<ul>\n<li>Object</li>\n</ul>\n<p>연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다.</p>\n<h2 id=\"symbol과-bigint\" style=\"position:relative;\"><a href=\"#symbol%EA%B3%BC-bigint\" aria-label=\"symbol과 bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol과 BigInt</h2>\n<h3 id=\"symbol\" style=\"position:relative;\"><a href=\"#symbol\" aria-label=\"symbol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol</h3>\n<p>: 코드 내에서 유일한 값을 가진 이름을 만들 때 사용</p>\n<p><code class=\"language-text\">const user = Symbol();   // 혹은 Symbol('this is user'); 설명을 덧붙일 수 있다</code></p>\n<p>이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값</p>\n<p>user === “this is user”; // false\nuser === ‘user’ // false</p>\n<p>똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false</p>\n<h3 id=\"bigint\" style=\"position:relative;\"><a href=\"#bigint\" aria-label=\"bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BigInt</h3>\n<p>: 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n최소, 최대 정수보다 큰 수의 연산이 필요한 경우 BigInt를 사용한다.</p>\n<p>사용방법: 일반 정수 마지막에 알파벳 ‘n’을 붙이거나 BigInt라는 함수 사용\n소수표현에는 사용할 수 없다.\n소수 형태 결과가 리턴되는 연산은 소수점 아래를 버리고 정수로 표현된다.\nBigInt끼리만 연산할 수 있고 서로 다른 타입은 명시적 타입 변환을 필요로 한다.</p>","frontmatter":{"date":"June 21, 2023","title":"모던 자바스크립트 (1)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-06-21/"}},"prev":{"id":"19bbbd2e-81a9-5730-8ca6-ca1c7e5100a2","html":"<h3 id=\"fetch\" style=\"position:relative;\"><a href=\"#fetch\" aria-label=\"fetch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fetch</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">feth('https://google.com')\n  .then((response) => response.text())\n  .then((result) => { console.log(result); });</code></pre></div>\n<p>fetch: 서버로 request를 보내고 response를 받는 함수\n파라미터로 넘어온 URL로 request를 보낸다.\nresponse를 받으면 받은 response를 처리하거나 사용하는 부분이 필요한데, then 안의 코드가 그것이다.\n서버가 보낸 response는 하나의 객체가 되어 파라미터로(여기서는 response이며 단어는 임의로 지정) 넘어온다.\nfetch 함수가 실행될 때 then 안의 구문이 바로 실행되는 것은 아니고 response가 도착한 후에 실행된다. 이처럼 어떤 조건이 만족되었을 때 실행되는 함수를 callback 함수라고 하며, then 메소드는 callback을 등록해주는 메소드인 걸 알 수 있다.\n이전 callback의 리턴 값은 다음 callback이 넘겨받을 수 있는데 위 코드에서는 result에 이전 callback의 리턴 값인 response.text()가 들어가 있다.\n<br>\nfetch 함수의 실행 원리를 정리해 보면 다음과 같다.</p>\n<ul>\n<li>fetch 함수는 어떤 객체(promise)를 리턴한다.</li>\n<li>이 객체의 then 메소드로 ‘response가 왔을 때 실행할 callback’을 등록할 수 있다.</li>\n<li>이렇게 등록된 callback들은 then 메소드로 등록한 순서대로 실행되며 이전 콜백의 리턴 값을 이후 콜백이 넘겨받아 사용할 수 있다.</li>\n</ul>\n<br>\n### JSON\nJavaScript Object Notation.\n자바스크립트 언어의 문법을 빌려 만들어진 데이터 포맷.\nJSON 문법은 자바스크립트 문법과 거의 유사하다.\n<br>\n### JavaScript 문법과의 차이\n- JSON은 프로퍼티 이름과 값을 표현하는 방식에 제한이 있다.\n\t- 프로퍼티 이름에 반드시 \"\"를 붙여야 한다. (JS는 붙여도 되고 안붙여도 됨)\n\t- 값이 문자열인 경우 \"\"로 감싸줘야 한다. (JS는 '' 혹은 \"\")\n- JSON은 undefined, NaN, Infinity 등을 사용할 수 없다.\n- 주석을 달 수 없다. 코드가 아닌 데이터 포맷이기 때문\n<br>\n### JSON 데이터 다루기\n1. string type의 JSON vs JS 객체\n- JSON.stringify(data): 자바스크립트의 객체는 정의하지 않아도 기본으로 내장하는 프로퍼티들이 존재하는데 이는 서버에 보낼 필요가 없는 것들. 따라서 객체의 데이터만을 string으로 변환하는 serialization을 해야 한다.\n- JSON.parse(result): 반대로 서버에서 JSON 데이터를 가져올 때 string type의 키를 가져올 수 없기 때문에 string type을 객체로 변환하는 deserialization을 해야 한다.\n2. JSON 메소드\nresponse의 내용을 추출하기 위해 response.text()를 호출한 후 JSON.parse(result) 과정을 거쳤는데 text 대신 json() 메소드를 사용하여 바로 deserialization을 할 수 있다.\n```\n/*\nfetch('URL')\n  .then((response) => response.text())\n  .then((result) => {\n    const users = JSON.parse(result);\n  });\n*/\n<p>fetch(‘URL’)\n.then((response) => response.json())\n.then((result) => { const users = result; });</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">response 객체의 json메소드를 호출하면 response 내용이 JSON에 해당하는 경우 바로 deserialization까지 수행. 하지만 JSON 데이터가 아닌 경우에 에러를 발생시킨다.\n&lt;br></code></pre></div>","frontmatter":{"date":"July 06, 2023","title":"JS 웹 개발 (1)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-06/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/2023-07-05/","nextSlug":"/2023-06-21/","prevSlug":"/2023-07-06/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
{"componentChunkName":"component---src-templates-blog-template-js","path":"/2023-07-07/","result":{"data":{"cur":{"id":"c1792e2f-7ebc-5184-8b22-6f51eef4bce0","html":"<h2 id=\"nodejs\" style=\"position:relative;\"><a href=\"#nodejs\" aria-label=\"nodejs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js</h2>\n<br>\n### Node.js\nJavaScript를 웹 브라우저 외에도 사용할 수 있게 하는 JS 실행 환경.\n- 서버에서 사용되는 프로그램을 만들 수 있고,\n- JS만 알아도 웹서비스를 만들 수 있다\n<p>는 장점을 가진다.</p>\n<p>node를 설치한 후 Visual Studio Code에서 간단한 코드를 작성한 뒤, 터미널에서\n<code class=\"language-text\">node 파일명</code>\n을 입력하면 파일이 실행된다.</p>\n<p>원래 JavaScript는 웹 브라우저 내에서만 실행할 수 있는 코드인데, node는 브라우저가 아닌 환경에서도 실행할 수 있게 한다.\n<br></p>\n<h3 id=\"require\" style=\"position:relative;\"><a href=\"#require\" aria-label=\"require permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>require</h3>\n<p>모듈을 로드해주는 함수\n<code class=\"language-text\">require(상대경로 / 파일 / 디렉토리이름)</code>\n실행하면 모듈을 로드해서 객체를 리턴해준다. 변수에 require가 리턴하는 객체를 할당해서 사용하면 된다.</p>\n<p>반대로 현재 모듈을 다른 모듈에서 사용하게 하려면 외부로 공개해줘야 한다. exports 키워드를 사용해서 공개할 수 있다.\n<code class=\"language-text\">exports module = module;</code>\nexports 뒤의 module은 모듈 외부로 공개할 이름을 뜻하고, 오른쪽의 module은 모듈 내부에서의 이름을 말한다.</p>\n<p>이때 공개하고 싶은 것들을 모아 하나의 객체로 만들고 그 객체를 공개할 수도 있다. 아래는 예시 코드이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let info = {\n\tname: \"Yuna Kim\",\n\temail: \"yuna123@node.js\",\n\tbirthdate: \"1994-01-01\",\n};\n\nmodule.exports = info;</code></pre></div>\n<p>정리하면,</p>\n<ul>\n<li>공개하고 싶은 모듈을 하나씩 exports 키워드로 공개할 수 있다.</li>\n<li>공개하고 싶은 것들을 모아 하나의 객체로 만들고 module.exports로 객체를 공개할 수도 있다.</li>\n</ul>\n<p>Node.js에서 모듈은</p>\n<ul>\n<li>직접 만든 모듈</li>\n<li>만들어져 있는 모듈</li>\n</ul>\n<p>이렇게 두 가지로 나눌 수 있는데, 만들어져 있는 모듈은 다시</p>\n<ul>\n<li>코어 모듈</li>\n<li>서드파티 모듈</li>\n</ul>\n<p>로 나눌 수 있다.</p>\n<p>코어 모듈: 노드 안에 이미 포함되어 있는 모듈을 뜻한다. 노드를 설치하면 바로 사용할 수 있다.\n서드파티 모듈: 개인 혹은 회사가 만들어 npm 저장소에서 제공하는 모듈.\n<br></p>\n<h3 id=\"비동기-프로그래밍\" style=\"position:relative;\"><a href=\"#%EB%B9%84%EB%8F%99%EA%B8%B0-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"비동기 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>비동기 프로그래밍</h3>\n<p>비동기 실행: 특정 작업이 완료되었을 때 실행할 콜백을 등록해두고 다음 작업으로 실행 흐름을 넘기는 것\nNode.js는 비동기 함수를 사용해 비동기 프로그래밍을 하는 것을 권장하고 있다.</p>\n<p>이때 비동기 프로그래밍을 하는 방법은 이벤트를 사용하는 것이다.\n이벤트란 어떤 일이 발생했음을 알리는 신호이다.</p>\n<p><code class=\"language-text\">const EventEmitter = require('events');</code>\nevents라는 코어모듈을 로드해서 사용할 수 있고, events는 EventEmitter라는 클래스를 공개하는 모듈이다.</p>\n<p><code class=\"language-text\">const myEmitter = new EventEmitter();</code>\nEventEmitter 클래스로 myEmitter라는 객체를 생성한다.</p>\n<p><code class=\"language-text\">myEmitter.on(eventName, listener)</code>\non 메소드를 이용해 이벤트가 발생했을 때 실행할 콜백을 등록할 수 있다.</p>\n<p><code class=\"language-text\">myEmitter.emit(eventName);</code>\n이후 emit 메소드로 이벤트를 직접 발생시킬 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const EventEmitter = require('events');\n\nconst myEmitter = new EventEmitter();\n\nmyEmitter.on('event', () => {\n\tconsole.log('Success');\n});\n\nmyEmitter.emit('event');</code></pre></div>\n<p>이때 request에는 client의 요청 정보가 담겨있으며, response 객체는 콜백 함수 안에서 가공되어 client로 보낼 데이터를 담을 객체이다.</p>\n<p>EventEmitter 객체는 많은 코어 모듈의 기반이 되기 때문에 제대로 이해하는 것이 중요하다.</p>\n<h3 id=\"eventemitter-사용법\" style=\"position:relative;\"><a href=\"#eventemitter-%EC%82%AC%EC%9A%A9%EB%B2%95\" aria-label=\"eventemitter 사용법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>EventEmitter 사용법</h3>\n<p>EventEmitter 객체를 사용할 때 주의할 점이 있는데, <strong>이벤트를 발생시키기 전에 콜백 설정을 먼저 해줘야 한다</strong>는 것이다.\n만약 이벤트를 먼저 발생시키면 콜백 함수가 등록된 후에는 어떠한 이벤트도 발생하지 않기 때문에 함수는 동작하지 않는다.</p>\n<p>이벤트의 특징에는 다음이 있다.</p>\n<ul>\n<li>하나의 이벤트에 여러 개의 콜백을 설정할 수 있다</li>\n<li>설정된 콜백들은 이벤트가 발생하면 등록된 순서대로 실행한다</li>\n<li>이벤트를 발생시키고 콜백이 실행되는 과정은 하나의 EventEmitter 객체에서만 이루어진다.</li>\n</ul>\n<p>예를 들어, 아래와 같은 코드를 실행시키면 어떤 결과가 출력될까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const EventEmitter = require('events');\nconst myEmitter = new EventEmitter();\nconst myEmitter2 = new EventEmitter();\n\nmyEmitter.on('event', () => {\n\tconsole.log('Success');\n});\n\nmyEmitter2.on('event', () => {\n\tconsole.log('Success2');\n});\n\nmyEmitter.emit('event');\nmyEmitter.emit('event');</code></pre></div>\n<p>정답은 Success가 두 번 출력된다. 이벤트 이름은 ‘event’로 같지만 이 이벤트를 발생시키는 객체는 myEmitter객체이고 이는 myEmitter2와는 다른 객체이기 때문이다.</p>\n<p><code class=\"language-text\">myEmitter.emit(eventName[, ...args]);</code>\n이벤트에 추가 정보를 함께 전달할 수도 있다. 전달할 정보를 추가 인자로 전달해주면 된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">myEmitter.on(eventName, (arg1, arg2) => {\n\tconsole.log(arg1);\n\tconsole.log(arg2);\n});</code></pre></div>\n<p>파라미터로 정보를 받아올 수 있다. 하지만 모든 인자를 받아야 하는 것은 아니다. 또한 여러 인자를 하나씩 넘겨주는 것 보다 여러 정보를 담은 객체 하나만을 넘겨주는 것이 좋다.\n<br></p>\n<h3 id=\"웹-서버-열어보기\" style=\"position:relative;\"><a href=\"#%EC%9B%B9-%EC%84%9C%EB%B2%84-%EC%97%B4%EC%96%B4%EB%B3%B4%EA%B8%B0\" aria-label=\"웹 서버 열어보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>웹 서버 열어보기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const http = require('http');\n\nconst server = http.createServer((req, res) => {\n\tconsole.log(req.url);\n});\n\nserver.listen(3000);</code></pre></div>\n<p>먼저 http 코어 모듈을 로드해 http 객체에 저장한다.\n이후 http 객체의 createServer 메소드로 서버를 열고, 클라이언트의 요청이 들어올 때마다 실행될 함수를 등록한다.\nserver.listen(3000);은 서버가 3000번의 포트 번호를 가지고 클라이언트의 요청을 기다리게 한다.\n<br></p>\n<h3 id=\"라우팅\" style=\"position:relative;\"><a href=\"#%EB%9D%BC%EC%9A%B0%ED%8C%85\" aria-label=\"라우팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>라우팅</h3>\n<p>요청이 들어온 URL에 따라 서버가 다른 응답을 보내게 하는 것을 URL 라우팅 혹은 라우팅이라고 한다. 라우팅은 서버에서 이루어져야 할 가장 기본적인 동작 중 하나이다.\nURL에 따라 다른 응답을 보내려면 클라이언트가 요청한 URL을 가져와야 한다.  URL은 req 객체의 프로퍼티로 들어오기 때문에 req.url 로 접근할 수 있다. 그러면 url은 도메인 네임 뒤의 /부터 경로를 모두 가져온다.</p>","excerpt":"Node.js 는 장점을 가진다. node를 설치한 후 Visual Studio Code에서 간단한 코드를 작성한 뒤, 터미널에서\n\n을 입력하면 파일이 실행된다. 원래 JavaScript는 웹 브라우저 내에서만 실행할 수 있는 코드인데, node는 브라우저가 아닌 환경에서도 실행할 수 있게 한다.\n require 모듈을 로드해주는 함수\n\n실행하면 모듈을 로드해서 객체를 리턴해준다. 변수에 require가 리턴하는 객체를 할당해서 사용하면 된다. 반대로 현재 모듈을 다른 모듈에서 사용하게 하려면 외부로 공개해줘야 한다. exports 키워드를 사용해서 공개할 수 있다.\n\nexports 뒤의 module은 모듈 외부로 공개할 이름을 뜻하고, 오른쪽의 module은 모듈 내부에서의 이름을 말한다. 이때 공개하고 싶은 것들을 모아 하나의 객체로 만들고 그 객체를 공개할 수도 있다. 아래는 예시 코드이다. 정리하면, 공개하고 싶은 모듈을 하나씩 exports 키워드로 공개할 수 있다. 공개…","frontmatter":{"date":"July 07, 2023","title":"Node.js 정리 (1)","categories":"Node.js","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-07/"}},"next":{"id":"19bbbd2e-81a9-5730-8ca6-ca1c7e5100a2","html":"<h3 id=\"fetch\" style=\"position:relative;\"><a href=\"#fetch\" aria-label=\"fetch permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>fetch</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">feth('https://google.com')\n  .then((response) => response.text())\n  .then((result) => { console.log(result); });</code></pre></div>\n<p>fetch: 서버로 request를 보내고 response를 받는 함수\n파라미터로 넘어온 URL로 request를 보낸다.\nresponse를 받으면 받은 response를 처리하거나 사용하는 부분이 필요한데, then 안의 코드가 그것이다.\n서버가 보낸 response는 하나의 객체가 되어 파라미터로(여기서는 response이며 단어는 임의로 지정) 넘어온다.\nfetch 함수가 실행될 때 then 안의 구문이 바로 실행되는 것은 아니고 response가 도착한 후에 실행된다. 이처럼 어떤 조건이 만족되었을 때 실행되는 함수를 callback 함수라고 하며, then 메소드는 callback을 등록해주는 메소드인 걸 알 수 있다.\n이전 callback의 리턴 값은 다음 callback이 넘겨받을 수 있는데 위 코드에서는 result에 이전 callback의 리턴 값인 response.text()가 들어가 있다.\n<br>\nfetch 함수의 실행 원리를 정리해 보면 다음과 같다.</p>\n<ul>\n<li>fetch 함수는 어떤 객체(promise)를 리턴한다.</li>\n<li>이 객체의 then 메소드로 ‘response가 왔을 때 실행할 callback’을 등록할 수 있다.</li>\n<li>이렇게 등록된 callback들은 then 메소드로 등록한 순서대로 실행되며 이전 콜백의 리턴 값을 이후 콜백이 넘겨받아 사용할 수 있다.</li>\n</ul>\n<br>\n### JSON\nJavaScript Object Notation.\n자바스크립트 언어의 문법을 빌려 만들어진 데이터 포맷.\nJSON 문법은 자바스크립트 문법과 거의 유사하다.\n<br>\n### JavaScript 문법과의 차이\n- JSON은 프로퍼티 이름과 값을 표현하는 방식에 제한이 있다.\n\t- 프로퍼티 이름에 반드시 \"\"를 붙여야 한다. (JS는 붙여도 되고 안붙여도 됨)\n\t- 값이 문자열인 경우 \"\"로 감싸줘야 한다. (JS는 '' 혹은 \"\")\n- JSON은 undefined, NaN, Infinity 등을 사용할 수 없다.\n- 주석을 달 수 없다. 코드가 아닌 데이터 포맷이기 때문\n<br>\n### JSON 데이터 다루기\n1. string type의 JSON vs JS 객체\n- JSON.stringify(data): 자바스크립트의 객체는 정의하지 않아도 기본으로 내장하는 프로퍼티들이 존재하는데 이는 서버에 보낼 필요가 없는 것들. 따라서 객체의 데이터만을 string으로 변환하는 serialization을 해야 한다.\n- JSON.parse(result): 반대로 서버에서 JSON 데이터를 가져올 때 string type의 키를 가져올 수 없기 때문에 string type을 객체로 변환하는 deserialization을 해야 한다.\n2. JSON 메소드\nresponse의 내용을 추출하기 위해 response.text()를 호출한 후 JSON.parse(result) 과정을 거쳤는데 text 대신 json() 메소드를 사용하여 바로 deserialization을 할 수 있다.\n```\n/*\nfetch('URL')\n  .then((response) => response.text())\n  .then((result) => {\n    const users = JSON.parse(result);\n  });\n*/\n<p>fetch(‘URL’)\n.then((response) => response.json())\n.then((result) => { const users = result; });</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">response 객체의 json메소드를 호출하면 response 내용이 JSON에 해당하는 경우 바로 deserialization까지 수행. 하지만 JSON 데이터가 아닌 경우에 에러를 발생시킨다.\n&lt;br></code></pre></div>","frontmatter":{"date":"July 06, 2023","title":"JS 웹 개발 (1)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-06/"}},"prev":{"id":"50c96e13-16dd-5686-8aef-a3b0cfe8b67e","html":"<h2 id=\"express\" style=\"position:relative;\"><a href=\"#express\" aria-label=\"express permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Express</h2>\n<h3 id=\"express-기초\" style=\"position:relative;\"><a href=\"#express-%EA%B8%B0%EC%B4%88\" aria-label=\"express 기초 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Express 기초</h3>\n<p>Express: Node.js 환경에서 실행되는 서버 프로그램을 만들 때 사용하는 웹 프레임워크. 서버 프로그램에 필요한 최소한의 기능만 제공하기 때문에 전체적인 구조 설계는 개발자의 몫이다.</p>\n<p>서버는 두 가지로 나뉜다.</p>\n<ul>\n<li>Web Server: 화면을 그리기 위해 필요한 HTML, CSS, JavaScript 코드들을 보내주는 서버</li>\n<li>API Server: Client가 request를 보내면 작업을 처리하고 결과 데이터를 response의 body에 담아서 보내는 서버</li>\n</ul>\n<p>이번 학습에서는 API Server를 만드는 것을 목표로 한다.</p>\n<p><code class=\"language-text\">const app = express();</code>\nexpress 객체를 생성한다. express로 만든 객체는 주로 app으로 하는 것이 관례이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get('/hello', (req, res) => {\n\tres.send('&lt;h1>Hello Express!&lt;/h1>);\n});</code></pre></div>\n<p>app.get(path, callback): 특정 path(여기서는 /hello)에 대해 들어온 요청과 응답을 다루는 콜백을 등록하는 함수이다.\nres.send([body]): HTTP response를 보내는 response 객체의 메소드. 파라미터는 Buffer, String, 객체, Boolean, 또는 배열일 수 있다. 여기서는 HTML 코드를 화면에 표시한다.\n특정 path에 대응하는 콜백을 route handler라고도 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.listen(3000, () => {\n\tconsole.log('Server is listening...');\n});</code></pre></div>\n<p>서버가 요청을 들을 준비를 마치고 나면 콜백이 자동으로 실행된다.\n<br>\n직원 정보를 다루는 API Server를 만들어 보자. 직원 정보를 조회, 추가, 수정, 삭제 등의 작업을 하는 서버이다.\n직원 정보가 담긴 JSON 데이터를 배열에 담고, 전체 직원 정보를 조회하는 코드는 다음과 같다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">let members = require('./members');\n\napp.get('/api/members', (req, res) => {\n\tres.send(members);\n});</code></pre></div>\n<p>그럼 특정 직원 한 명의 정보는 어떻게 조회할 수 있을까.\n예를 들어, 특정 직원의 정보를 요청하는 URL의 path가 ‘/api/members/2’와 같다고 할 때 members/ 뒤의 숫자는 직원에 따라 다 다를 것이다. 그렇다면 이처럼 URL에 가변적인 값이 들어가는 경우에는 어떻게 처리할까?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get('/api/members/:id', (req, res) => {\n\t// const id = req.params.id;\n\tconst { id } = req.params;\n\tconst member = members.find((m) => m.id === Number(id));\n\tif (member) {\n\t\tres.send(member);\n\t} else {\n\t\tres.status(404).send({ message: \"There is no such member\" });\n\t}\n});</code></pre></div>\n<p>path에 있는 “:id”와 같은 부분을 route parameter라고 한다. ”:” 기호는 뒤에 오는 값을 req.params의 id 속성에 담으라는 express의 표기법이다.\n즉 ‘/api/members/2’에서 2라는 값은 req.params.id의 값이 된다.\n이제 members 배열에서 해당 id와 일치하는 직원을 찾아 member에 넘겨주면 되는데 <code class=\"language-text\">const member = members.find((m) => m.id === Number(id));</code> 가 그것이다. 배열의 find 메소드를 이용해, 인자로 들어온 콜백함수가 true인 여러 요소 중 첫 번째 요소를 리턴한다.\n해당 직원의 정보가 없을 때를 else문 안에서 처리하고 있다. 리퀘스트가 요청한 id의 직원 정보가 없다면, response의 상태 코드에 적절한 코드를 설정해줘야 한다. 여기서는 404 코드를 설정해주었다. 이때 body에 추가 메시지를 담아 보내려면 send 메소드를 뒤이어 붙이고, 인자로 정보를 넣어주면 된다. 문자열 자체를 보내는 것보다, 메시지도 하나의 JSON 데이터 형태로 넣어주는 게 나중에 추가 정보를 넣어야 할 때 확장하기 용이하다.\n<br>\n이제 특정 팀에 속한 직원들을 조회해보자.\n경로는 /api/members?team=engineering 혹은 /api/members?team=marketing 과 같이 정할 수 잇다. 이때 ?부터 시작하는 부분은 query 라고 한다.\n서버에 있는 리소스를 조회할 때 필터하거나 정렬하는 기준을 정하기 위해 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.get('/api/members', (req, res) => {\n\tconst { team } = req.query;\n\tif (team) {\n\t\tconst teamMembers = members.filter((m) => m.team === team);\n\t\tres.send(teamMembers);\n\t} else {\n\t\tres.send(members);\n\t}\n});</code></pre></div>\n<p>먼저 URL의 query문은 req 객체의 query로 가져올 수 있다.\n여기서 if로 분기를 나눠 team이 있다면 team에 속한 직원들 정보를 필터해 보내줄 것이고, 그렇지 않다면 전체 직원 정보를 조회하도록 한다.\nteam에 속한 직원들은 filter 메소드를 이용해 가져온다. filter는 배열의 각 요소를 순회하면서 콜백이 true인 요소만 모아 새로운 배열을 만든다.\n<br></p>\n<h3 id=\"post-리퀘스트\" style=\"position:relative;\"><a href=\"#post-%EB%A6%AC%ED%80%98%EC%8A%A4%ED%8A%B8\" aria-label=\"post 리퀘스트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>POST 리퀘스트</h3>\n<p>POST 리퀘스트는 새 직원을 추가하고자 할 때 사용한다.\n사실 get 메소드는 GET 리퀘스트만 담당하는 메소드이다. POST 리퀘스트를 처리하려면 post 메소드를 사용하면 된다.\nPOST 리퀘스트는 직원 정보를 리퀘스트의 바디에 담아서 보내기 때문에 서버에서 바디의 내용을 별도 처리해줘야 한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.post('/api/members', (req, res) => {\n\tconsole.log(req.body);\n})</code></pre></div>\n<p>현재로서는 브라우저에서 리퀘스트를 보낼 수 없기 때문에 rest client 플러그인을 설치해 리퀘스트를 보내도록 한다.\n설치한 후 test.http라는 http 확장자를 가진 파일을 추가하고 <code class=\"language-text\">GET http://localhost:포트번호</code> 이렇게 작성하면 Send Request 버튼이 생기는데, 버튼을 누르면 request가 보내지고 response 화면이 나타난다.\n밑에 ###(리퀘스트를 구분하기 위한 표시)를 해주고 POST 리퀘스트를 작성해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET http://localhost:3000/api/members\n\n###\nPOST http://localhost:3000/api/members\nContent-Type: application/json\n\n{\n\tid: 11,\n\tname: 어쩌구,\n\t...\n}</code></pre></div>\n<p>POST 리퀘스트 문장과 밑의 Content-Type 문장까지가 리퀘스트의 head, 밑의 데이터 부분이 body이다.\n하지만 이렇게 리퀘스트를 보내면 undefined가 출력되는데, req의 body에 내용을 담으려면 한 가지 작업이 필요하다.\n익스프레스를 사용할 때 바디가 있는 리퀘스트를 처리하려면 <code class=\"language-text\">app.use(express.json());</code> 코드를 추가해주어야 한다. 이 메소드는 리퀘스트의 바디에 JSON 데이터가 있으면 그것을 추출해서 req 객체의 body프로퍼티의 값으로 설정해준다. 이렇게 리퀘스터가 핸들러에 의해 처리되기 전에 별도의 처리를 수행하는 함수를 익스프레스에서는 middleware라고 한다.\n이제 정보가 잘 들어오므로 들어온 정보를 배열에 추가하고 조회할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">app.post('/api/members', (req, res) => {\n\tconst newMember = req.body;\n\tmembers.push(newMember);\n\tres.send(newMember);\n});</code></pre></div>\n<br>\n### PUT 리퀘스트\n```\napp.put('/api/members/:id', (req, res) => {\n\tconst { id } = req.params;\n\tconst newInfo = req.body;\n\tconst member = members.find((m) => m.id === Number(id));\n\tif (member) {\n\t\tObject.keys(newInfo).forEach((prop) => {\n\t\t\tmember[prop] = newInfo[prop];\n\t\t});\n\t\tres.send(member);\n\t} else {\n\t\tres.status(404).send({ message: \"There is no member with the id!\" });\n\t}\n});\n```\n- path에서 id 추출\n- response body에서 새로운 직원 정보 추출\n- 수정할 직원 특정\n- 만약 해당 id를 가진 직원이 존재한다면\n\t- newInfo 객체의 프로퍼티를 순회하면서 기존 데이터의 값에 newInfo의 값 저장\n\t- Object 객체의 keys 메소드를 사용하면 특정 객체의 모든 프로퍼티를 순회할 수 있다\n- 직원이 존재하지 않는다면\n\t- 404코드 처리\n<br>\n### DELETE 리퀘스트\n```\napp.delete('/api/members/:id', (req, res) => {\n\tconst { id } = req.params;\n\tconst membersCount = members.length;\n\tconst members = members.filter((m) => m.id !== Number(id));\n\tif (members.length < membersCount) {\n\t\tres.send('Deleted!');\n\t} else {\n\t\tres.status(404).send({ message: \"There is no member with the id!\" });\n\t}\n});\n```","frontmatter":{"date":"July 09, 2023","title":"Express 정리 (1)","categories":"Express","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-09/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/2023-07-07/","nextSlug":"/2023-07-06/","prevSlug":"/2023-07-09/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
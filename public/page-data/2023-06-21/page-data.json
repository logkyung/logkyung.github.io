{"componentChunkName":"component---src-templates-blog-template-js","path":"/2023-06-21/","result":{"data":{"cur":{"id":"1524538a-fc68-5429-9a45-1944f31e5eb1","html":"<h2 id=\"데이터-타입의-특징과-종류\" style=\"position:relative;\"><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8A%B9%EC%A7%95%EA%B3%BC-%EC%A2%85%EB%A5%98\" aria-label=\"데이터 타입의 특징과 종류 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>데이터 타입의 특징과 종류</h2>\n<p>기본형(Primitive Type)</p>\n<ul>\n<li>Number</li>\n<li>String</li>\n<li>Boolean</li>\n<li>Null</li>\n<li>Undefined</li>\n<li>Symbol: 유일값 만들 때</li>\n<li>BigInt: 매우 큰 수 다룰 떄</li>\n</ul>\n<p>참조형(Reference Type)</p>\n<ul>\n<li>Object</li>\n</ul>\n<p>연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다.</p>\n<h2 id=\"symbol과-bigint\" style=\"position:relative;\"><a href=\"#symbol%EA%B3%BC-bigint\" aria-label=\"symbol과 bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol과 BigInt</h2>\n<h3 id=\"symbol\" style=\"position:relative;\"><a href=\"#symbol\" aria-label=\"symbol permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Symbol</h3>\n<p>: 코드 내에서 유일한 값을 가진 이름을 만들 때 사용</p>\n<p><code class=\"language-text\">const user = Symbol();   // 혹은 Symbol('this is user'); 설명을 덧붙일 수 있다</code></p>\n<p>이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값</p>\n<p>user === “this is user”; // false\nuser === ‘user’ // false</p>\n<p>똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false</p>\n<h3 id=\"bigint\" style=\"position:relative;\"><a href=\"#bigint\" aria-label=\"bigint permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BigInt</h3>\n<p>: 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n최소, 최대 정수보다 큰 수의 연산이 필요한 경우 BigInt를 사용한다.</p>\n<p>사용방법: 일반 정수 마지막에 알파벳 ‘n’을 붙이거나 BigInt라는 함수 사용\n소수표현에는 사용할 수 없다.\n소수 형태 결과가 리턴되는 연산은 소수점 아래를 버리고 정수로 표현된다.\nBigInt끼리만 연산할 수 있고 서로 다른 타입은 명시적 타입 변환을 필요로 한다.</p>","excerpt":"데이터 타입의 특징과 종류 기본형(Primitive Type) Number String Boolean Null Undefined Symbol: 유일값 만들 때 BigInt: 매우 큰 수 다룰 떄 참조형(Reference Type) Object 연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다. Symbol과 BigInt Symbol : 코드 내에서 유일한 값을 가진 이름을 만들 때 사용  이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값 user === “this is user”; // false\nuser === ‘user’ // false 똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false BigInt : 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n…","frontmatter":{"date":"June 21, 2023","title":"모던 자바스크립트 (1)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-06-21/"}},"next":{"id":"fb6a0237-07ae-59dc-aa8b-ae99c2f2ad27","html":"<h2 id=\"9강-연결-리스트-3\" style=\"position:relative;\"><a href=\"#9%EA%B0%95-%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8-3\" aria-label=\"9강 연결 리스트 3 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9강. 연결 리스트 (3)</h2>\n<h3 id=\"연결-리스트가-유용한-경우\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EA%B2%B0-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EA%B0%80-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EA%B2%BD%EC%9A%B0\" aria-label=\"연결 리스트가 유용한 경우 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연결 리스트가 유용한 경우</h3>\n<p>연결 리스트의 장점: 삽입과 삭제가 유용하다\n따라서 중간 삽입과 삭제가 빈번한 시나리오의 경우 연결리스트 사용이 유리할 수 있다.\n하지만 현재의 연결 리스트는 삽입과 삭제 시 position을 앞에서부터 탐색해서 찾아와야 하기 때문에 그다지 유용한 것 같지 않음\n이에 대한 해결책으로 새로운 메서드를 만든다</p>\n<ul>\n<li>insertAt(prev, newNode)</li>\n<li>popAfter(prev)</li>\n</ul>\n<p>position을 인자로 주는 것이 아니라 한 노드를 넘겨주고 그 뒤에 삽입, 뒤의 노드를 삭제하는 방법으로 변경\n하지만 head 노드의 경우 prev 노드가 없는데 어떻게 할 것인가? 하는 문제 발생\n이를 위해 head에 dummy node 추가</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class LinkedList:\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = None\n        self.tail = None\n        self.head.next = self.tail</code></pre></div>\n<p>원소 삽입</p>\n<ul>\n<li>prev가 가리키는 node의 다음에</li>\n<li>newNode를 삽입</li>\n<li>성공/실패에 따라 True/False 반환</li>\n</ul>\n<p>원소 삭제</p>\n<ul>\n<li>prev의 다음 node 삭제</li>\n<li>그 node의 data를 리턴</li>\n<li>주의사항\n<ul>\n<li>prev가 마지막 node일 때: return None</li>\n<li>리스트의 마지막 node 삭제할 때: Tail 조정</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"연습문제\" style=\"position:relative;\"><a href=\"#%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C\" aria-label=\"연습문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>연습문제</h3>\n<p>제 9 강에서 소개된 추상적 자료구조 LinkedList 는 dummy head node 를 가지는 연결 리스트입니다. 이 클래스의 popAfter(), popAt() 메서드들을, 강의 내용에 소개된 요구조건을 만족시키도록 구현하세요.\n이 때, popAt() 메서드의 구현에서는 popAfter() 를 호출하여 이용하도록 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Node:\n\n    def __init__(self, item):\n        self.data = item\n        self.next = None\n\n\nclass LinkedList:\n\n    def __init__(self):\n        self.nodeCount = 0\n        self.head = Node(None)\n        self.tail = None\n        self.head.next = self.tail\n\n\n    def traverse(self):\n        result = []\n        curr = self.head\n        while curr.next:\n            curr = curr.next\n            result.append(curr.data)\n        return result\n\n\n    def getAt(self, pos):\n        if pos &lt; 0 or pos > self.nodeCount:\n            return None\n\n        i = 0\n        curr = self.head\n        while i &lt; pos:\n            curr = curr.next\n            i += 1\n\n        return curr\n\n\n    def insertAfter(self, prev, newNode):\n        newNode.next = prev.next\n        if prev.next is None:\n            self.tail = newNode\n        prev.next = newNode\n        self.nodeCount += 1\n        return True\n\n\n    def insertAt(self, pos, newNode):\n        if pos &lt; 1 or pos > self.nodeCount + 1:\n            return False\n\n        if pos != 1 and pos == self.nodeCount + 1:\n            prev = self.tail\n        else:\n            prev = self.getAt(pos - 1)\n        return self.insertAfter(prev, newNode)\n\n\n    def popAfter(self, prev):\n        if prev.next == None:\n            return None\n        curr = prev.next\n        prev.next = curr.next\n        if curr.next == None:\n            self.tail = prev\n        self.nodeCount -= 1\n        return curr.data\n\n\n    def popAt(self, pos):\n        if pos &lt; 0 or pos > self.nodeCount:\n            raise IndexError\n        prev = self.getAt(pos-1)\n        return self.popAfter(prev)\n\n\ndef solution(x):\n    return 0</code></pre></div>","frontmatter":{"date":"May 31, 2023","title":"파이썬 자료구조와 알고리즘 (4)","categories":"블로그","author":"logkyung","emoji":"💡"},"fields":{"slug":"/TIL_230531/"}},"prev":{"id":"efd3d1de-ce46-5613-8ae3-9d7ef2bf8456","html":"<h2 id=\"and와-or의-연산-방식\" style=\"position:relative;\"><a href=\"#and%EC%99%80-or%EC%9D%98-%EC%97%B0%EC%82%B0-%EB%B0%A9%EC%8B%9D\" aria-label=\"and와 or의 연산 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AND와 OR의 연산 방식</h2>\n<p>자바스크립트에서 논리 연산자는 매번 true나 false를 리턴하는 게 아니라 상황에 따라서 양쪽 값 중 하나를 선택하는 방식으로 동작한다.</p>\n<h3 id=\"and-연산자\" style=\"position:relative;\"><a href=\"#and-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"and 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>AND 연산자</h3>\n<p>왼쪽 값이 Truthy면 오르쪽 값 리턴, 왼쪽 값이 Falsy면 왼쪽 값 리턴\n<code class=\"language-text\">console.log(\"Python &amp;&amp; JavaScript\");  // Python이 Truthy이므로 JavaScript 리턴</code></p>\n<h3 id=\"or-연산자\" style=\"position:relative;\"><a href=\"#or-%EC%97%B0%EC%82%B0%EC%9E%90\" aria-label=\"or 연산자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OR 연산자</h3>\n<p>왼쪽 값이 Truthy면 왼쪽 값 리턴, 왼쪽 값이 Falsy면 오른쪽 값 리턴</p>\n<ul>\n<li>null &#x26;&#x26; undefined   // null</li>\n<li>0 || true           // true</li>\n<li>‘0’ &#x26;&#x26; NaN          // NaN</li>\n<li>{} || 123           // {}</li>\n</ul>\n<br>\n<h2 id=\"null-병합-연산자-\" style=\"position:relative;\"><a href=\"#null-%EB%B3%91%ED%95%A9-%EC%97%B0%EC%82%B0%EC%9E%90-\" aria-label=\"null 병합 연산자  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>null 병합 연산자: ??</h2>\n<p>?? 연산자 왼편의 값이 null이거나 undefined라면 연산자 오른쪽 값 리턴, 아니면 왼쪽 값 리턴\n동작 방식은 OR 연산과 비슷하지만 병합 연산자는 왼편 값이 null/undefined인지 확인하고 OR은 falsy인지 확인한다는 차이점이 있다.</p>\n<br>\n<h2 id=\"변수와-스코프\" style=\"position:relative;\"><a href=\"#%EB%B3%80%EC%88%98%EC%99%80-%EC%8A%A4%EC%BD%94%ED%94%84\" aria-label=\"변수와 스코프 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변수와 스코프</h2>\n<p>값의 재할당이 필요한 경우 let\n필요하지 않은 경우 const</p>\n<ol>\n<li>변수가 유효한 시점의 차이</li>\n</ol>\n<p>var는 변수를 만들기도 전에 사용 가능하다는 문제가 있다.\nhoisting: 코드 상에서는 선언이 나중에 되었지만 선언이 위로 올라간 듯한 현상\nlet이나 const는 변수 선언 전에 사용할 수 없다.</p>\n<ol start=\"2\">\n<li>var는 중복 선언이 가능하다는 문제</li>\n<li>scope 차이</li>\n</ol>\n<p>var는 함수 스코프\nlet, const는 블록 스코프</p>\n<br>\n<h2 id=\"함수-만드는-방법\" style=\"position:relative;\"><a href=\"#%ED%95%A8%EC%88%98-%EB%A7%8C%EB%93%9C%EB%8A%94-%EB%B0%A9%EB%B2%95\" aria-label=\"함수 만드는 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>함수 만드는 방법</h2>\n<h3 id=\"1-함수-선언-function-declaration\" style=\"position:relative;\"><a href=\"#1-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8-function-declaration\" aria-label=\"1 함수 선언 function declaration permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 함수 선언 (Function Declaration)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function 함수이름(파라미터) {\n  동작\n  return 리턴값\n}</code></pre></div>\n<h3 id=\"2-함수-표현식function-expression\" style=\"position:relative;\"><a href=\"#2-%ED%95%A8%EC%88%98-%ED%91%9C%ED%98%84%EC%8B%9Dfunction-expression\" aria-label=\"2 함수 표현식function expression permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 함수 표현식(Function Expression)</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const printHello = function() {\n  console.log(\"Hello\");\n};</code></pre></div>\n<p>변수에 함수 선언을 할당하는 방식이다.\n함수 선언은 호이스팅이 가능하지만 표현식은 불가능하다.\n또한 함수 선언은 함수 스코프를 가진다. 표현식은 할당된 변수에 따라 스코프가 달라진다.</p>\n<br>\n<h2 id=\"파라미터와-아규먼트\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%99%80-%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8\" aria-label=\"파라미터와 아규먼트 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터와 아규먼트</h2>\n<h3 id=\"파라미터parameter\" style=\"position:relative;\"><a href=\"#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0parameter\" aria-label=\"파라미터parameter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>파라미터(Parameter)</h3>\n<p>함수에서 넘겨받는 부분을 파라미터라고 한다.\n함수를 호출할 때 undefined를 넘겨 기본값이 동작하게 할 수 있다.\n파라미터의 기본값은 앞쪽에 정의된 파라미터를 활용할 수 있다.</p>\n<h3 id=\"아규먼트argument\" style=\"position:relative;\"><a href=\"#%EC%95%84%EA%B7%9C%EB%A8%BC%ED%8A%B8argument\" aria-label=\"아규먼트argument permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>아규먼트(Argument)</h3>\n<p>함수 호출 시 파라미터로 넘겨주는 값을 의미한다.\n아규먼트 개수에 따라 유연하게 동작하는 함수를 만드려면 함수 내부에서 arguments라는 아규먼트를 다루는 특별한 객체를 사용할 수 있다.</p>\n<h3 id=\"rest-parameter\" style=\"position:relative;\"><a href=\"#rest-parameter\" aria-label=\"rest parameter permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rest Parameter</h3>\n<p>파라미터 앞에 마침표 세 개를 붙여서 사용한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function name(...paramenter) {\n\n}</code></pre></div>\n<p>arguments 객체는 유사 배열이라 배열의 메소드를 사용할 수 없다.\n반면 Rest Parameter는 배열이기 때문에 배열의 메소드를 활용할 수 있다.\n일반 파라미터와 함께 사용할 수도 있는데 그럴 땐 반드시 가장 마지막에 작성하도록 한다.</p>\n<br>\n<h2 id=\"arrow-function\" style=\"position:relative;\"><a href=\"#arrow-function\" aria-label=\"arrow function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Arrow Function</h2>\n<p>기존 함수의 선언 방식을 보다 간결하게 만들어주는 문법이다.\n이름이 없는 익명함수이기 때문에 이름을 가진 변수에 할당하거나, 다른 함수의 아규먼트를 선언할 때 활용할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">() => {\n  동작\n}</code></pre></div>\n<p>더 짧게 표현도 가능한데</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">number => number*2</code></pre></div>\n<ul>\n<li>파라미터가 하나인 arrow function은 소괄호 부분을 생략할 수 있다.</li>\n<li>파라미터가 두 개 이상이거나 없을 경우 반드시 작성해야 한다.</li>\n<li>내부 동작 부분이 return문 하나로만 이루어져 있다면 중괄호와 함께 리턴 키워드를 생략할 수 있다.</li>\n<li>함수 내부에 리턴문 하나밖에 없지만 리턴 값이 객체인 경우 객체를 소괄호로 감싸야 한다.</li>\n<li>arrow function에는 arguments 객체가 없다.</li>\n</ul>\n<br>\n<h2 id=\"this\" style=\"position:relative;\"><a href=\"#this\" aria-label=\"this permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>this</h2>\n<p>브라우저 안에서 자바스크립트가 동작한다면 전역 객체인 window 객체가 this의 기본값이다.\n함수 내부에서 사용할 수 있는데 특히 객체의 메소드를 만들 때 사용한다.\n자바스크립트에서 this는 함수를 호출한 객체를 가리키는 키워드이다.\n일반 함수와 arrow function은 this를 다루는 방식이 다르다.\narrow function에서 this는 호출할 대상에 따라 상대적으로 변하는 것이 아니다.\narror function이 선언되기 직전에 유효한 this 값과 같은 값을 갖게 된다.\n이런 특징 때문에 객체에 메소드를 만들 때는 arrow function보다 일반 함수 사용을 권장한다.</p>\n<br>\n<h2 id=\"객체-지향-프로그래밍\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"객체 지향 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 프로그래밍</h2>\n<p>‘객체’간의 상호작용을 중심으로 하는 프로그래밍</p>\n<h3 id=\"객체-만들기\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EB%A7%8C%EB%93%A4%EA%B8%B0\" aria-label=\"객체 만들기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 만들기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">const user = {\n  email: 'abc123@gmail.com',\n  birth: '1997-01-01',\n  buy(item) {\n    console.log(\"this.email buys item.name\");\n  },\n}\n\nconst item = {\n  name: '스웨터',\n  price: 20000,\n}</code></pre></div>\n<h3 id=\"factory-function\" style=\"position:relative;\"><a href=\"#factory-function\" aria-label=\"factory function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Factory Function</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createUser(email, birth) {\n  const user = {\n    email,\n    birth,\n    buy(item) {\n      console.log('this.email buys item.name');\n    },\n  };\n  return user\n}\n\nconst user1 = createUser('abc123@gmail.com', '1997-01-01');\n</code></pre></div>\n<p>객체를 생성해서 return하는 함수를 Factory Function이라고 한다.</p>\n<h3 id=\"constructor-function\" style=\"position:relative;\"><a href=\"#constructor-function\" aria-label=\"constructor function permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Constructor Function</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function User(email, birth) {\n  this.email = email,\n  this.birth = birth,\n  this.buy = function(item) {\n    console.log('위랑 똑같음');\n  };\n}\n\nconst user1 = new User(email, birth);</code></pre></div>\n<p>this 키워드는 constructor function으로 생성할 수 있는 해당 객체를 의미한다.\n객체를 여러 개 생성했을 때 각각의 값이 다르게 잘 설정되는 이유는 constructor function의 this가 매번 생성되는 해당 객체를 가리키기 때문이다.</p>\n<ul>\n<li>constructor function으로 객체를 생성하려면 new를 붙여서 호출</li>\n<li>일반 함수와 달리 함수 이름의 첫 번째 알파벳을 대문자로</li>\n</ul>\n<h3 id=\"class\" style=\"position:relative;\"><a href=\"#class\" aria-label=\"class permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Class</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class User {\n  constructor(email, birth) {\n    this.email = email,\n    this.birth = birth,\n  }\n\n  buy(item) {\n    console.log('위');\n  }\n}</code></pre></div>\n<ul>\n<li>new 키워드로 객체 생성</li>\n<li>constructor 안에 프로퍼티, 바깥에 메소드를 정의</li>\n</ul>\n<h3 id=\"추상화\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81%ED%99%94\" aria-label=\"추상화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상화</h3>\n<p>객체 지향 프로그래밍의 핵심 개념 네 가지(추상화, 캡슐화, 상속, 다형성) 중 하나\n어떤 구체적인 존재를 원하는 방향으로 간략화 해서 나타내는 것을 말한다.</p>\n<h3 id=\"캡슐화\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94\" aria-label=\"캡슐화 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화</h3>\n<p>객체의 특정 프로퍼티에 직접 접근하지 못하도록 막는 것을 말한다.\nsetter/getter 메소드를 통해 구현할 수 있다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">set email(address) {\n  if (address.includes('@')) {\n    this._email = address;\n  } else {\n    throw new Error(\"invalid email address\");\n  }\n}</code></pre></div>\n<p>숨기고자 하는 프로퍼티 이름을 _를 붙이고 써준다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">get email() {\n  return this._email;\n}</code></pre></div>\n<p>원래 있던 email 프로퍼티는 _email 프로퍼티로 교체하고 _email에 직접 접근하기보다 getter, setter를 통해 접근하게 한다.\n특정 프로퍼티에 대한 접근을 미리 정해진 메소드를 통해서만 가능하게 하는 것을 캡슐화라고 하며 캡슐화를 함으로써 프로그램의 안정성을 높일 수 있다.</p>\n<h3 id=\"캡슐화-더-알아보기\" style=\"position:relative;\"><a href=\"#%EC%BA%A1%EC%8A%90%ED%99%94-%EB%8D%94-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0\" aria-label=\"캡슐화 더 알아보기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>캡슐화 더 알아보기</h3>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function createUser(email, birthdate) {\n  let _email = email;\n\n  const user = {\n    birthdate,\n\n    get email() {\n      return _email;\n    },\n\n    set email(address) {\n      if (address.includes('@')) {\n        _email = address;\n      } else {\n        throw new Error('invalid email address');\n      }\n    },\n  };\n\n  return user;\n}</code></pre></div>\n<ul>\n<li>createUser 함수 안에, 객체 바깥에 _email 함수를 선언</li>\n<li>대신 user 객체 안에는 email이라는 getter/setter 설정</li>\n<li>closure: 어떤 함수와 그 함수가 참조할 수 있는 값들로 이루어진 환경을 하나로 묶은 것</li>\n<li>createUser 함수가 실행되는 시점에 email이라는 getter/setter 메소드는 _email이라는 변수 값에 접근할 수 있는 상태</li>\n<li>그리고 핵심은 getter/setter 메소드는 객체가 리턴된 후에도 여전히 _email에 접근하는 것이 가능하다는 것</li>\n<li>이처럼 함수가 정의된 당시에 참조할 수 있었던 변수들을 계속 참조할 수 있는 상태의 함수를 클로저라고 한다.</li>\n</ul>\n<h3 id=\"상속inheritance\" style=\"position:relative;\"><a href=\"#%EC%83%81%EC%86%8Dinheritance\" aria-label=\"상속inheritance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상속(Inheritance)</h3>\n<p>하나의 객체가 다른 객체의 프로퍼티와 메소드를 물려받는 것\n상속받은 자식 클래스는 super 생성자를 호출해야 한다.</p>\n<p>자식 클래스를 만들 때는 자식 클래스의 생성자 안에서 super를 통해 부모 클래스의 생성자 함수를 먼저 호출해줘야 한다.</p>\n<h3 id=\"다형성polymorphism\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1polymorphism\" aria-label=\"다형성polymorphism permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성(Polymorphism)</h3>\n<p>많은 형태를 갖고 있는 성질</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">buy(item) {\n  console.log('this.email buys item.name with a 5% discount');\n}\n\nusers = [user 배열]\n\nusers.forEach((user) => {\n  user.buy(item);\n});</code></pre></div>\n<p>하나의 변수가 다양한 종류의 객체를 가리킬 수 있는 것을 다형성이라고 한다.</p>","frontmatter":{"date":"July 05, 2023","title":"모던 자바스크립트 (2)","categories":"JavaScript","author":"logkyung","emoji":"💡"},"fields":{"slug":"/2023-07-05/"}},"site":{"siteMetadata":{"siteUrl":"https://logkyung.github.io","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/2023-06-21/","nextSlug":"/TIL_230531/","prevSlug":"/2023-07-05/"}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
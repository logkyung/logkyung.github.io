{"componentChunkName":"component---src-templates-category-template-js","path":"/posts/JavaScript","result":{"pageContext":{"currentCategory":"JavaScript","categories":["All","JavaScript","Express","Node.js","블로그"],"edges":[{"node":{"id":"40d818ea-b84d-50e1-8a4e-60bb43caa9fc","excerpt":"JavaScript id로 태그 선택하기 \n단 하나의 요소만 선택할 때는 태그에 id를 부여하고 getElementById 메소드를 사용한다. 존재하지 않는 id의 태그에 접근하려고 하면 null을 리턴한다. class로 태그 선택 \n같은 클래스 이름을 가진 태그들의 배열의 형태로 리턴된다. 완벽한 배열이 아니기 때문에 배열의 메소드를 사용할 수는 없지만, 대괄호 표기법으로 요소들에 접근하거나 length를 사용하거나 for…of문을 사용할 수 있어 유사배열(Array-Like Object)이라고 한다.  순서는 태그의 깊이와 상관 없이 위에서부터 순서대로이다. 만약 없는 값에 접근하면 undefined 값을 리턴한다. 또 한 가지 주의할 점은 같은 클래스 이름을 여러 태그가 가질 수 있기 때문에 메소드 이름이 Elements라는 것. 태그 이름으로 선택 \n클래스로 태그 선택할 때와 마찬가지로 같은 종류의 태그들이 배열의 형태로 리턴된다. 역시 유사배열의 형태를 가지고 있으며, c…","fields":{"slug":"/2023-07-13/"},"frontmatter":{"categories":"JavaScript","title":"Interactive JavaScript (1)","date":"July 13, 2023"}},"next":{"fields":{"slug":"/2023-07-11/"}},"previous":null},{"node":{"id":"19bbbd2e-81a9-5730-8ca6-ca1c7e5100a2","excerpt":"fetch fetch: 서버로 request를 보내고 response를 받는 함수\n파라미터로 넘어온 URL로 request를 보낸다.\nresponse를 받으면 받은 response를 처리하거나 사용하는 부분이 필요한데, then 안의 코드가 그것이다.\n서버가 보낸 response는 하나의 객체가 되어 파라미터로(여기서는 response이며 단어는 임의로 지정) 넘어온다.\nfetch 함수가 실행될 때 then 안의 구문이 바로 실행되는 것은 아니고 response가 도착한 후에 실행된다. 이처럼 어떤 조건이 만족되었을 때 실행되는 함수를 callback 함수라고 하며, then 메소드는 callback을 등록해주는 메소드인 걸 알 수 있다.\n이전 callback의 리턴 값은 다음 callback이 넘겨받을 수 있는데 위 코드에서는 result에 이전 callback의 리턴 값인 response.text()가 들어가 있다.\n\nfetch 함수의 실행 원리를 정리해 보면 다음과 같다. f…","fields":{"slug":"/2023-07-06/"},"frontmatter":{"categories":"JavaScript","title":"JS 웹 개발 (1)","date":"July 06, 2023"}},"next":{"fields":{"slug":"/2023-07-05/"}},"previous":{"fields":{"slug":"/2023-07-07/"}}},{"node":{"id":"efd3d1de-ce46-5613-8ae3-9d7ef2bf8456","excerpt":"AND와 OR의 연산 방식 자바스크립트에서 논리 연산자는 매번 true나 false를 리턴하는 게 아니라 상황에 따라서 양쪽 값 중 하나를 선택하는 방식으로 동작한다. AND 연산자 왼쪽 값이 Truthy면 오르쪽 값 리턴, 왼쪽 값이 Falsy면 왼쪽 값 리턴\n OR 연산자 왼쪽 값이 Truthy면 왼쪽 값 리턴, 왼쪽 값이 Falsy면 오른쪽 값 리턴 null && undefined   // null 0 || true           // true ‘0’ && NaN          // NaN {} || 123           // {} null 병합 연산자: ?? ?? 연산자 왼편의 값이 null이거나 undefined라면 연산자 오른쪽 값 리턴, 아니면 왼쪽 값 리턴\n동작 방식은 OR 연산과 비슷하지만 병합 연산자는 왼편 값이 null/undefined인지 확인하고 OR은 falsy인지 확인한다는 차이점이 있다. 변수와 스코프 값의 재할당이 필요한 경우 let\n필요하지…","fields":{"slug":"/2023-07-05/"},"frontmatter":{"categories":"JavaScript","title":"모던 자바스크립트 (2)","date":"July 05, 2023"}},"next":{"fields":{"slug":"/2023-06-21/"}},"previous":{"fields":{"slug":"/2023-07-06/"}}},{"node":{"id":"1524538a-fc68-5429-9a45-1944f31e5eb1","excerpt":"데이터 타입의 특징과 종류 기본형(Primitive Type) Number String Boolean Null Undefined Symbol: 유일값 만들 때 BigInt: 매우 큰 수 다룰 떄 참조형(Reference Type) Object 연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다. Symbol과 BigInt Symbol : 코드 내에서 유일한 값을 가진 이름을 만들 때 사용  이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값 user === “this is user”; // false\nuser === ‘user’ // false 똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false BigInt : 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n…","fields":{"slug":"/2023-06-21/"},"frontmatter":{"categories":"JavaScript","title":"모던 자바스크립트 (1)","date":"June 21, 2023"}},"next":{"fields":{"slug":"/TIL_230531/"}},"previous":{"fields":{"slug":"/2023-07-05/"}}}]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}
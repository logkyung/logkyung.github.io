{"componentChunkName":"component---src-templates-category-template-js","path":"/posts","result":{"pageContext":{"currentCategory":"All","edges":[{"node":{"id":"40d818ea-b84d-50e1-8a4e-60bb43caa9fc","excerpt":"JavaScript id로 태그 선택하기 \n단 하나의 요소만 선택할 때는 태그에 id를 부여하고 getElementById 메소드를 사용한다. 존재하지 않는 id의 태그에 접근하려고 하면 null을 리턴한다. class로 태그 선택 \n같은 클래스 이름을 가진 태그들의 배열의 형태로 리턴된다. 완벽한 배열이 아니기 때문에 배열의 메소드를 사용할 수는 없지만, 대괄호 표기법으로 요소들에 접근하거나 length를 사용하거나 for…of문을 사용할 수 있어 유사배열(Array-Like Object)이라고 한다.  순서는 태그의 깊이와 상관 없이 위에서부터 순서대로이다. 만약 없는 값에 접근하면 undefined 값을 리턴한다. 또 한 가지 주의할 점은 같은 클래스 이름을 여러 태그가 가질 수 있기 때문에 메소드 이름이 Elements라는 것. 태그 이름으로 선택 \n클래스로 태그 선택할 때와 마찬가지로 같은 종류의 태그들이 배열의 형태로 리턴된다. 역시 유사배열의 형태를 가지고 있으며, c…","fields":{"slug":"/2023-07-13/"},"frontmatter":{"categories":"JavaScript","title":"Interactive JavaScript (1)","date":"July 13, 2023"}},"next":{"fields":{"slug":"/2023-07-11/"}},"previous":null},{"node":{"id":"78abc3fb-aada-5a1d-bb87-d5d90db5853a","excerpt":"Express (2) ORM으로 데이터베이스 작업 자바스크립트로 데이터베이스를 다루기 위해서는 ‘클라이언트 객체’가 필요하다. 클라이언트 객체를 사용하기 위해서는, ORM을 이용해 자바스크립트로 작성한 데이터베이스 관련 코드를 자동으로 SQL로 변환한 후 클라이언트 객체를 통해 데이터베이스로 전달하는 방식이 있다. 필요한 패키지를 설치한다.  Sequelize를 사용하기 위한 준비작업  config, migrations, models 디렉토리 생성 config/config.json 파일 생성 models/index.js 파일 생성 config.json의 development 객체에 db 정보 설정 데이터베이스 생성 \n개발용 환경의 데이터베이스 생성 테이블 생성 \n데이터베이스에서 하나의 테이블은 sequelize에서 하나의 class에 해당하고, class의 객체 하나는 테이블에서 하나의 row에 해당한다.\n이때 modelName은 단수로 쓴다. 하지만 sequelize는 자동으로 …","fields":{"slug":"/2023-07-11/"},"frontmatter":{"categories":"Express","title":"Express 정리 (2)","date":"July 11, 2023"}},"next":{"fields":{"slug":"/2023-07-09/"}},"previous":{"fields":{"slug":"/2023-07-13/"}}},{"node":{"id":"50c96e13-16dd-5686-8aef-a3b0cfe8b67e","excerpt":"Express Express 기초 Express: Node.js 환경에서 실행되는 서버 프로그램을 만들 때 사용하는 웹 프레임워크. 서버 프로그램에 필요한 최소한의 기능만 제공하기 때문에 전체적인 구조 설계는 개발자의 몫이다. 서버는 두 가지로 나뉜다. Web Server: 화면을 그리기 위해 필요한 HTML, CSS, JavaScript 코드들을 보내주는 서버 API Server: Client가 request를 보내면 작업을 처리하고 결과 데이터를 response의 body에 담아서 보내는 서버 이번 학습에서는 API Server를 만드는 것을 목표로 한다. \nexpress 객체를 생성한다. express로 만든 객체는 주로 app으로 하는 것이 관례이다. app.get(path, callback): 특정 path(여기서는 /hello)에 대해 들어온 요청과 응답을 다루는 콜백을 등록하는 함수이다.\nres.send([body]): HTTP response를 보내는 response…","fields":{"slug":"/2023-07-09/"},"frontmatter":{"categories":"Express","title":"Express 정리 (1)","date":"July 09, 2023"}},"next":{"fields":{"slug":"/2023-07-07/"}},"previous":{"fields":{"slug":"/2023-07-11/"}}},{"node":{"id":"c1792e2f-7ebc-5184-8b22-6f51eef4bce0","excerpt":"Node.js 는 장점을 가진다. node를 설치한 후 Visual Studio Code에서 간단한 코드를 작성한 뒤, 터미널에서\n\n을 입력하면 파일이 실행된다. 원래 JavaScript는 웹 브라우저 내에서만 실행할 수 있는 코드인데, node는 브라우저가 아닌 환경에서도 실행할 수 있게 한다.\n require 모듈을 로드해주는 함수\n\n실행하면 모듈을 로드해서 객체를 리턴해준다. 변수에 require가 리턴하는 객체를 할당해서 사용하면 된다. 반대로 현재 모듈을 다른 모듈에서 사용하게 하려면 외부로 공개해줘야 한다. exports 키워드를 사용해서 공개할 수 있다.\n\nexports 뒤의 module은 모듈 외부로 공개할 이름을 뜻하고, 오른쪽의 module은 모듈 내부에서의 이름을 말한다. 이때 공개하고 싶은 것들을 모아 하나의 객체로 만들고 그 객체를 공개할 수도 있다. 아래는 예시 코드이다. 정리하면, 공개하고 싶은 모듈을 하나씩 exports 키워드로 공개할 수 있다. 공개…","fields":{"slug":"/2023-07-07/"},"frontmatter":{"categories":"Node.js","title":"Node.js 정리 (1)","date":"July 07, 2023"}},"next":{"fields":{"slug":"/2023-07-06/"}},"previous":{"fields":{"slug":"/2023-07-09/"}}},{"node":{"id":"19bbbd2e-81a9-5730-8ca6-ca1c7e5100a2","excerpt":"fetch fetch: 서버로 request를 보내고 response를 받는 함수\n파라미터로 넘어온 URL로 request를 보낸다.\nresponse를 받으면 받은 response를 처리하거나 사용하는 부분이 필요한데, then 안의 코드가 그것이다.\n서버가 보낸 response는 하나의 객체가 되어 파라미터로(여기서는 response이며 단어는 임의로 지정) 넘어온다.\nfetch 함수가 실행될 때 then 안의 구문이 바로 실행되는 것은 아니고 response가 도착한 후에 실행된다. 이처럼 어떤 조건이 만족되었을 때 실행되는 함수를 callback 함수라고 하며, then 메소드는 callback을 등록해주는 메소드인 걸 알 수 있다.\n이전 callback의 리턴 값은 다음 callback이 넘겨받을 수 있는데 위 코드에서는 result에 이전 callback의 리턴 값인 response.text()가 들어가 있다.\n\nfetch 함수의 실행 원리를 정리해 보면 다음과 같다. f…","fields":{"slug":"/2023-07-06/"},"frontmatter":{"categories":"JavaScript","title":"JS 웹 개발 (1)","date":"July 06, 2023"}},"next":{"fields":{"slug":"/2023-07-05/"}},"previous":{"fields":{"slug":"/2023-07-07/"}}},{"node":{"id":"efd3d1de-ce46-5613-8ae3-9d7ef2bf8456","excerpt":"AND와 OR의 연산 방식 자바스크립트에서 논리 연산자는 매번 true나 false를 리턴하는 게 아니라 상황에 따라서 양쪽 값 중 하나를 선택하는 방식으로 동작한다. AND 연산자 왼쪽 값이 Truthy면 오르쪽 값 리턴, 왼쪽 값이 Falsy면 왼쪽 값 리턴\n OR 연산자 왼쪽 값이 Truthy면 왼쪽 값 리턴, 왼쪽 값이 Falsy면 오른쪽 값 리턴 null && undefined   // null 0 || true           // true ‘0’ && NaN          // NaN {} || 123           // {} null 병합 연산자: ?? ?? 연산자 왼편의 값이 null이거나 undefined라면 연산자 오른쪽 값 리턴, 아니면 왼쪽 값 리턴\n동작 방식은 OR 연산과 비슷하지만 병합 연산자는 왼편 값이 null/undefined인지 확인하고 OR은 falsy인지 확인한다는 차이점이 있다. 변수와 스코프 값의 재할당이 필요한 경우 let\n필요하지…","fields":{"slug":"/2023-07-05/"},"frontmatter":{"categories":"JavaScript","title":"모던 자바스크립트 (2)","date":"July 05, 2023"}},"next":{"fields":{"slug":"/2023-06-21/"}},"previous":{"fields":{"slug":"/2023-07-06/"}}},{"node":{"id":"1524538a-fc68-5429-9a45-1944f31e5eb1","excerpt":"데이터 타입의 특징과 종류 기본형(Primitive Type) Number String Boolean Null Undefined Symbol: 유일값 만들 때 BigInt: 매우 큰 수 다룰 떄 참조형(Reference Type) Object 연산 시 데이터 타입이 유연하게 변할 수 있다는 특징은 간결하고 편리한 코드 작성에 도움이 된다. Symbol과 BigInt Symbol : 코드 내에서 유일한 값을 가진 이름을 만들 때 사용  이렇게 생성된 user라는 이름의 변수는 어떤 값과 비교해도 true가 될 수 없는 고유한 값 user === “this is user”; // false\nuser === ‘user’ // false 똑같은 설명을 가지고 있는 심볼이라 하더라도 두 값을 비교하면 false BigInt : 자바스크립트에서 안전한 최대 정수는 2^53-1, 최소 정수는 -(2^53-1)로 대략 9천조이다.\n이 숫자 범위를 초과하는 정수값은 미세한 오류가 발생하게 된다.\n…","fields":{"slug":"/2023-06-21/"},"frontmatter":{"categories":"JavaScript","title":"모던 자바스크립트 (1)","date":"June 21, 2023"}},"next":{"fields":{"slug":"/TIL_230531/"}},"previous":{"fields":{"slug":"/2023-07-05/"}}},{"node":{"id":"fb6a0237-07ae-59dc-aa8b-ae99c2f2ad27","excerpt":"9강. 연결 리스트 (3) 연결 리스트가 유용한 경우 연결 리스트의 장점: 삽입과 삭제가 유용하다\n따라서 중간 삽입과 삭제가 빈번한 시나리오의 경우 연결리스트 사용이 유리할 수 있다.\n하지만 현재의 연결 리스트는 삽입과 삭제 시 position을 앞에서부터 탐색해서 찾아와야 하기 때문에 그다지 유용한 것 같지 않음\n이에 대한 해결책으로 새로운 메서드를 만든다 insertAt(prev, newNode) popAfter(prev) position을 인자로 주는 것이 아니라 한 노드를 넘겨주고 그 뒤에 삽입, 뒤의 노드를 삭제하는 방법으로 변경\n하지만 head 노드의 경우 prev 노드가 없는데 어떻게 할 것인가? 하는 문제 발생\n이를 위해 head에 dummy node 추가 원소 삽입 prev가 가리키는 node의 다음에 newNode를 삽입 성공/실패에 따라 True/False 반환 원소 삭제 prev의 다음 node 삭제 그 node의 data를 리턴 주의사항 prev가 마지막 n…","fields":{"slug":"/TIL_230531/"},"frontmatter":{"categories":"블로그","title":"파이썬 자료구조와 알고리즘 (4)","date":"May 31, 2023"}},"next":{"fields":{"slug":"/TIL_230528/"}},"previous":{"fields":{"slug":"/2023-06-21/"}}},{"node":{"id":"c9b21417-b504-5fbe-85e2-1fb87a81a001","excerpt":"6강. 알고리즘 복잡도(Complexity) 시간 복잡도 문제 크기와 해결 시간 사이의 관계 공간 복잡도 문제 크기와 필요한 메모리 공간 사이 관계 Big-O Notation 알고리즘 복잡도를 표현할 때 쓰이는 점근 표기법 중 하나\n예를 들어, 입력의 크기가 n일 때 O(log n): 입력의 크기의 로그에 비례하는 시간 소요 O(n): 입력 크기에 비례하는 시간 소요 선형 시간 알고리즘: O(n) 무작위 배열에서 최댓값을 찾는 문제에 해당\n끝까지 살펴보기 전에는 알 수 없다 Average Case: O(n) Worst Case: O(n) 로그 시간 알고리즘: O(log n) 크기순으로 정렬된 배열에서 이진 탐색하는 문제 이차 시간 알고리즘 삽입 정렬과 같은 문제 보다 낮은 복잡도를 가지는 정렬 알고리즘 병합 정렬(merge sort)의 경우 O(nlogn)\n정렬 문제에 대해 O(nlogn)보다 낮은 복잡도를 갖는 알고리즘은 없다.\n 7강. 연결 리스트 (Linked List) (1…","fields":{"slug":"/TIL_230528/"},"frontmatter":{"categories":"블로그","title":"파이썬 자료구조와 알고리즘 (3)","date":"May 28, 2023"}},"next":{"fields":{"slug":"/TIL_230527/"}},"previous":{"fields":{"slug":"/TIL_230531/"}}},{"node":{"id":"ee1d717f-6704-5dd3-a387-a5e899936b60","excerpt":"3강 ~ 5강 3강. 정렬(sort), 탐색(search) 정렬 배열의 원소들을 정해진 기준에 따라 나열하는 것 ex) 오름차순 정렬, 내림차순 정렬 sorted(L, key=lambda x: len(x)) # [‘xyz’, ‘abcd’, ‘spam’] L = [{‘name’: ‘John’, ‘score’: 83},\n{‘name’: ‘Paul’, ‘score’: 92}]\nL.sort(key=lambda x: x[‘name’]) # 이름 순으로 정렬\nL.sort(key=lambda x: x[‘score’], reverse=True) # 점수가 높은 순으로 정렬 def solution(L, x):\nstart, end = 0, len(L)-1\nwhile start <= end:\nmid = (start+end)//2\nif L[mid] == x:\nreturn mid\nelif L[mid] < x:      # 중간 값이 x보다 작으면 왼쪽 탐색 종료\nstart = mid+1\nelse:    …","fields":{"slug":"/TIL_230527/"},"frontmatter":{"categories":"블로그","title":"파이썬 자료구조와 알고리즘 (2)","date":"May 27, 2023"}},"next":{"fields":{"slug":"/Python_Algorithm/"}},"previous":{"fields":{"slug":"/TIL_230528/"}}},{"node":{"id":"deb25420-1614-5eac-a10b-0734b6b28ffa","excerpt":"(1) 정렬된 리스트에 원소 삽입 문제 설명 리스트 L과 정수 x가 인자로 주어질 때, 리스트 내의 올바른 위치에 x를 삽입하여 그 결과 리스트를 반환하는 함수 solution을 완성하세요. My solution My solution","fields":{"slug":"/Python_Algorithm/"},"frontmatter":{"categories":"블로그","title":"파이썬 자료구조와 알고리즘","date":"May 26, 2023"}},"next":{"fields":{"slug":"/JavaScript/"}},"previous":{"fields":{"slug":"/TIL_230527/"}}},{"node":{"id":"f06dc468-9d22-5009-a357-b7321552bf92","excerpt":"💡 JavaScript 문법 정리 return 함수의 역할은 값 반환 , 함수 종료 두 가지가 있다. 함수에 return문의 없으면 함수 종료 시 undefined 반환. undefined값의 경우 변수를 선언하고 아무 값도 할당하지 않았을 때 반환 값이 없는 함수를 호출한 경우 파라미터가 있는 함수에 호출 시 아무 값도 넘겨주지 않을 때 옵셔널 파라미터 함수 정의 시 파라미터에 기본 값을 할당해 준 경우 옵셔널 파라미터라고 함. 옵셔널 파라미터는 선언할 때 가장 마지막에 해줘야 한다. 상수 선언 시 const 키워드 사용  값을 재할당할 수 없기 때문에 값을 보호할 수 있다. 선언 시 값을 할당해주지 않으면 안된다. 상수 이름은 대문자와 밑줄로 표현해야 한다. for statement 증감부는 채울 필요 없이 block 내에 작성해도 됨 하지만 for 특성 상 증감부가 있기 때문에 block 내의 동작부에는 실제 반복할 내용만 집중, 조건과 관련된 부분은 소괄호 내의 증감부에 작…","fields":{"slug":"/JavaScript/"},"frontmatter":{"categories":"블로그","title":"JavaScript","date":"May 21, 2023"}},"next":{"fields":{"slug":"/2023-05-19/"}},"previous":{"fields":{"slug":"/Python_Algorithm/"}}},{"node":{"id":"7e551952-51ef-5871-87ba-4f3278e84ced","excerpt":"1. 테스트 글입니다. 변경사항이 잘 반영이 되어야 할텐데…","fields":{"slug":"/2023-05-19/"},"frontmatter":{"categories":"블로그","title":"테스트 게시글입니다 !","date":"May 19, 2023"}},"next":null,"previous":{"fields":{"slug":"/JavaScript/"}}}],"categories":["All","JavaScript","Express","Node.js","블로그"]}},"staticQueryHashes":["1073350324","1956554647","2938748437"]}